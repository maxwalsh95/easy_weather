SCRIPT  /home/max/.local/share/nvim/plugged/vim-doge/ftplugin/javascript.vim
Sourced 4 times
Total time:   0.004223
 Self time:   0.000909

count  total (s)   self (s)
                            " ==============================================================================
                            " The JavaScript documentation should follow the 'jsdoc' conventions.
                            " see https://jsdoc.app
                            " ==============================================================================
                            
    4              0.000010 let s:save_cpo = &cpoptions
    4              0.000014 set cpoptions&vim
                            
    4              0.000010 let b:doge_pattern_single_line_comment = '\m\(\/\*.\{-}\*\/\|\/\/.\{-}$\)'
    4              0.000007 let b:doge_pattern_multi_line_comment = '\m\/\*.\{-}\*\/'
                            
    4   0.000292   0.000129 let b:doge_supported_doc_standards = doge#buffer#get_supported_doc_standards(['jsdoc'])
    4   0.000047   0.000018 let b:doge_doc_standard = doge#buffer#get_doc_standard('javascript')
    4   0.000028   0.000014 let b:doge_patterns = doge#buffer#get_patterns()
                            
                            " ==============================================================================
                            "
                            " Define our base for every pattern.
                            "
                            " ==============================================================================
                            " The parameters.match describes the following pattern:
                            "   <param-access> @<decorator> <param-name>: <param-type> = <param-default-value>
                            " ==============================================================================
                            
    4              0.000049 let s:pattern_base = {
                            \  'parameters': {
                            \    'match': '\m\%(\%(public\|private\|protected\)\?\s*\)\?\%(@[[:alnum:]_]\+(.\{-})\s\+\)\?\([[:alnum:]_$]\+\)?\?\%(\s*:\s*\([[:alnum:]._| ]\+\%(\[[[:alnum:][:space:]_[\],]*\]\)\?\|([[:alnum:].:_| ]\+)\s*=>\s*[[:alnum:]_.]\+\)\)\?\%(\s*=\s*\([[:alnum:]_.]\+(.\{-})\|[^,]\+\)\+\)\?',
                            \    'tokens': ['name', 'type', 'default'],
                            \    'format': '@param {{type|!type}} %(default|[)%{name}%(default|])% - !description',
                            \  },
                            \  'insert': 'above',
                            \}
                            
                            " ==============================================================================
                            "
                            " Define the pattern types.
                            "
                            " ==============================================================================
                            
                            " ------------------------------------------------------------------------------
                            " Matches fat-arrow / functions inside objects.
                            " ------------------------------------------------------------------------------
                            " myKey: function myRealFunction(p1, p2) {}
                            " myKey: async function myRealFunction(p1, p2) {}
                            " myKey: (p1, p2) => {}
                            " myKey: async (p1, p2) => {}
                            " ------------------------------------------------------------------------------
    4   0.000420   0.000050 let s:object_functions_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'match': '\m^[[:punct:]]\?\([[:alnum:]_-]\+\)[[:punct:]]\?\s*:\s*\(async\)\?\s*\%(function\)\?\s*\%([[:alnum:]_]\+\)\?(\(.\{-}\))\%(\s*:\s*(\?\([[:alnum:][:space:]_[\].,|<>]\+\))\?\)\?\%(\s*=>\s*\)\?\s*[({]',
                            \  'tokens': ['funcName', 'async', 'parameters', 'returnType'],
                            \})
                            
                            " ------------------------------------------------------------------------------
                            " Matches class declarations.
                            " ------------------------------------------------------------------------------
                            " export class Child {}
                            " class Child extends Parent {}
                            " class Child implements CustomInterfaceName {}
                            " export class Child extends Parent implements CustomInterfaceName {}
                            " ------------------------------------------------------------------------------
    4   0.000374   0.000042 let s:class_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'match': '\m^\%(\%(export\|export\s\+default\)\s\+\)\?class\s\+\%([[:alnum:]_$]\+\)\%(\s\+extends\s\+\([[:alnum:]_$.]\+\)\)\?\%(\s\+implements\s\+\([[:alnum:]_$.]\+\)\)\?\s*{',
                            \  'tokens': ['parentClassName', 'interfaceName'],
                            \})
    4              0.000011 unlet s:class_pattern['parameters']
                            
                            " ------------------------------------------------------------------------------
                            " Matches regular and typed functions with default parameters.
                            " ------------------------------------------------------------------------------
                            " function add(one: any, two: any = 'default'): number {}
                            " export function configureStore(history: History, initialState: object): Store<AppState> {}
                            " function configureStore(history: History, initialState: object): Store {}
                            " function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {}
                            " function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {}
                            " ------------------------------------------------------------------------------
    4   0.000385   0.000061 let s:function_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'match': '\m^\%(\%(export\|export\s\+default\|public\|private\|protected\)\s\+\)*\(static\s\+\)\?\(async\s\+\)\?\%(function\(\*\)\?\s*\)\?\%([[:alnum:]_$]\+\)\?\s*\%(<[[:alnum:][:space:]_,=]*>\)\?\s*(\(.\{-}\))\%(\s*:\s*(\?\([[:alnum:][:space:]_[\].,|<>]\+\))\?\)\?\s*[{(]',
                            \  'tokens': ['static', 'async', 'generator', 'parameters', 'returnType'],
                            \})
                            
                            " ------------------------------------------------------------------------------
                            " Matches prototype functions.
                            " ------------------------------------------------------------------------------
                            " Person.prototype.greet = (p1: string = 'default', p2: Immutable.List = Immutable.List()) => {};
                            " Person.prototype.greet = function (p1: string = 'default', p2: Immutable.List = Immutable.List()) {};
                            " Person.prototype.greet = function*(p1: string = 'default', p2: Immutable.List = Immutable.List()) {};
                            " ------------------------------------------------------------------------------
    4   0.000365   0.000046 let s:prototype_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'match': '\m^\([[:alnum:]_$]\+\)\.prototype\.\([[:alnum:]_$]\+\)\s*=\s*\(async\s\+\)\?\%(function\(\*\)\?\s*\)\?({\?\([^>]\{-}\)}\?)\%(\s*:\s*(\?\([[:alnum:][:space:]_[\].,|<>]\+\))\?\)\?\s*\(=>\s*\)\?[{(]',
                            \  'tokens': ['className', 'funcName', 'async', 'generator', 'parameters', 'returnType'],
                            \})
                            
                            " ------------------------------------------------------------------------------
                            " Matches fat-arrow functions.
                            " ------------------------------------------------------------------------------
                            " var myFunc = function($p1 = 'value', p2 = [], p3, p4) {}
                            " var myFunc = function*($p1 = 'value', p2 = [], p3, p4) {}
                            " var myFunc = async function*($p1 = 'value', p2 = [], p3, p4) {}
                            " var myFunc = async ($p1 = 'value', p2 = [], p3, p4) => {}
                            " (p1: array = []) => (p2: string) => { console.log(5); }
                            " (p1: array = []) => (p2: string) => { console.log(5); }
                            " static myMethod({ b: number }): number {}
                            " static async myMethod({ b: number }): number {}
                            " const user = (p1 = 'default') => (subp1, subp2 = 'default') => 5;
                            " const foo = bar => baz
                            " export const foo = bar => baz
                            " (p1: string = 'default', p2: int = 5, p3, p4: Immutable.List = [], p5: string[] = [], p6: float = 0.5): number[] => { };
                            " ------------------------------------------------------------------------------
    4   0.000381   0.000056 let s:fat_arrow_function_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'match': '\m^\%(\%(export\|export\s\+default\)\s\+\)\?\%(\%(\%(var\|const\|let\)\s\+\)\?\%(\(static\)\s\+\)\?\([[:alnum:]_$]\+\)\)\?\s*=\s*\(static\s\+\)\?\(async\s\+\)\?\%(function\(\*\)\?\s*\)\?\(({\?[^>]\{-}}\?)\|[[:alnum:]_$]\+\)\%(\s*:\s*(\?\([[:alnum:][:space:]_[\].,|<>]\+\))\?\)\?\s*\%(=>\s*\)\?[^ ]\{-}',
                            \  'tokens': ['static', 'funcName', 'static', 'async', 'generator', 'parameters', 'returnType'],
                            \})
                            
                            " ==============================================================================
                            "
                            " Define the doc standards.
                            "
                            " ==============================================================================
    4   0.001683   0.000245 call doge#buffer#register_doc_standard('jsdoc', [
                            \  doge#helpers#deepextend(s:object_functions_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * !description',
                            \      ' *',
                            \      '%(async| * @{async})%',
                            \      ' * @function {funcName|}',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return {{returnType|!type}} !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * !description',
                            \      '%(parentClassName| * @extends {parentClassName})%',
                            \      '%(interfaceName| * @implements {interfaceName})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * !description',
                            \      ' *',
                            \      '%(static| * @static)%',
                            \      '%(async| * @async)%',
                            \      '%(generator| * @generator)%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return {{returnType|!type}} !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:prototype_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * !description',
                            \      ' *',
                            \      '%(async| * @async)%',
                            \      ' * @function {className}#{funcName}',
                            \      '%(generator| * @generator)%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return {{returnType|!type}} !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:fat_arrow_function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * !description',
                            \      ' *',
                            \      '%(static| * @static)%',
                            \      '%(async| * @async)%',
                            \      ' * @function {funcName|}',
                            \      '%(generator| * @generator)%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return {{returnType|!type}} !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \])
                            
    4              0.000014 let &cpoptions = s:save_cpo
    4              0.000010 unlet s:save_cpo

SCRIPT  /home/max/.local/share/nvim/plugged/vim-doge/autoload/doge/buffer.vim
Sourced 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000003 let s:save_cpo = &cpoptions
    1              0.000003 set cpoptions&vim
                            
                            " The testing framework Vader is running everything inside a single buffer, so
                            " we disable the inheritance of some buffer-local variables to prevent extra
                            " work and/or failing tests.
                            
                            ""
                            " @public
                            " Returns a bool whether the current buffer is a supported filetype.
    1              0.000002 function! doge#buffer#initialized() abort
                              return exists('b:doge_supported_doc_standards') == v:true
                            endfunction
                            
                            ""
                            " @public
                            " 'defaults': A list of supported doc standards that should be allowed.
                            " Returns a list of accepted doc standards.
    1              0.000002 function! doge#buffer#get_supported_doc_standards(defaults) abort
                              if get(g:, 'doge_test_env', 0)
                                return a:defaults
                              endif
                            
                              " We sort them so that we can use uniq() on it.
                              let l:docs = uniq(sort(extend(get(b:, 'doge_supported_doc_standards', []), a:defaults)))
                            
                              " After sorted it, we will remove the defaults and prepend the defaults so
                              " that we can reset the order as we defined it in the ftplugin/{ft}.vim.
                              for l:default in a:defaults
                                call remove(l:docs, index(l:docs, l:default))
                              endfor
                            
                              " Prepend the defaults to the filtered docs list.
                              return extend(a:defaults, l:docs)
                            endfunction
                            
                            ""
                            " @public
                            " 'filetype': The filetype where we initialized the b:doge_doc_standard.
                            " Returns the current active doc standard.
    1              0.000002 function! doge#buffer#get_doc_standard(filetype) abort
                              return get(g:, 'doge_test_env', 0)
                                \ ? b:doge_supported_doc_standards[0]
                                \ : get(b:, 'doge_doc_standard', get(g:, 'doge_doc_standard_' . a:filetype, b:doge_supported_doc_standards[0]))
                            endfunction
                            
                            ""
                            " @public
                            " Returns the b:doge_patterns variable value.
    1              0.000002 function! doge#buffer#get_patterns() abort
                              return get(g:, 'doge_test_env', 0)
                                \ ? {}
                                \ : get(b:, 'doge_patterns', {})
                            endfunction
                            
                            ""
                            " @public
                            " Add a doc standard to the b:doge_patterns variable.
    1              0.000002 function! doge#buffer#register_doc_standard(doc_standard, patterns) abort
                              if has_key(b:doge_patterns, a:doc_standard) == v:false
                                let b:doge_patterns[a:doc_standard] = a:patterns
                              endif
                              return b:doge_patterns
                            endfunction
                            
    1              0.000004 let &cpoptions = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /home/max/.local/share/nvim/plugged/splitjoin.vim/ftplugin/javascript/splitjoin.vim
Sourced 4 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    4              0.000017 if !exists('b:splitjoin_split_callbacks')
    1              0.000008   let b:splitjoin_split_callbacks = [
                                    \ 'sj#js#SplitFunction',
                                    \ 'sj#js#SplitObjectLiteral',
                                    \ 'sj#js#SplitFatArrowFunction',
                                    \ 'sj#js#SplitArray',
                                    \ 'sj#js#SplitOneLineIf',
                                    \ 'sj#js#SplitArgs',
                                    \ ]
    4              0.000003 endif
                            
    4              0.000009 if !exists('b:splitjoin_join_callbacks')
    1              0.000007   let b:splitjoin_join_callbacks = [
                                    \ 'sj#js#JoinFatArrowFunction',
                                    \ 'sj#js#JoinArray',
                                    \ 'sj#js#JoinArgs',
                                    \ 'sj#js#JoinFunction',
                                    \ 'sj#js#JoinOneLineIf',
                                    \ 'sj#js#JoinObjectLiteral',
                                    \ ]
    4              0.000004 endif

SCRIPT  /usr/share/nvim/runtime/ftplugin/javascript.vim
Sourced 4 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Javascript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:  2008 Jun 15
                            " URL:		http://gus.gscit.monash.edu.au/~djkea2/vim/ftplugin/javascript.vim
                            
    4              0.000011 if exists("b:did_ftplugin")
                              finish
    4              0.000002 endif
    4              0.000007 let b:did_ftplugin = 1
                            
    4              0.000015 let s:cpo_save = &cpo
    4              0.000021 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " " and insert the comment leader when hitting <CR> or using "o".
    4              0.000014 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    4              0.000010 if exists('&ofu')
    4              0.000010     setlocal omnifunc=javascriptcomplete#CompleteJS
    4              0.000002 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    4              0.000012 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    4              0.000006 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show Java-related files.
    4              0.000013 if has("gui_win32")
                                let  b:browsefilter="Javascript Files (*.js)\t*.js\n" .
                            		\	"All Files (*.*)\t*.*\n"
    4              0.000002 endif
                                   
    4              0.000007 let b:undo_ftplugin = "setl fo< ofu< com< cms<" 
                            
    4              0.000016 let &cpo = s:cpo_save
    4              0.000007 unlet s:cpo_save

SCRIPT  /home/max/.local/share/nvim/plugged/vim-javascript/after/ftplugin/javascript.vim
Sourced 4 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    4              0.000101 setlocal iskeyword+=$ suffixesadd+=.js
                            
    4              0.000012 if exists('b:undo_ftplugin')
    4              0.000011   let b:undo_ftplugin .= ' | setlocal iskeyword< suffixesadd<'
                            else
                              let b:undo_ftplugin = 'setlocal iskeyword< suffixesadd<'
    4              0.000004 endif

SCRIPT  /home/max/.local/share/nvim/plugged/vim-styled-components/after/ftplugin/javascript.vim
Sourced 4 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:   styled-components (js/ts)
                            " Maintainer: Karl Fleischmann <fleischmann.karl@gmail.com>
                            " URL:        https://github.com/styled-components/vim-styled-components
                            
    4              0.000011 fu! s:GetSyntaxNames(lnum, cnum)
                              return map(synstack(a:lnum, a:cnum), 'synIDattr(v:val, "name")')
                            endfu
                            
                            " re-implement SynSOL of vim-jsx
    4              0.000005 fu! s:SynSOL(lnum)
                              return s:GetSyntaxNames(a:lnum, 1)
                            endfu
                            
                            "" Return whether the current line is a jsTemplateString
    4              0.000005 fu! IsStyledDefinition(lnum)
                              " iterate through all syntax items in the given line
                              for item in s:SynSOL(a:lnum)
                                " if syntax-item is a jsTemplateString return 1 - true
                                " `==#` is a match case comparison of the item
                                if item ==# 'styledDefinition'
                                  return 1
                                endif
                              endfor
                            
                              " fallback to 0 - false
                              return 0
                            endfu
                            
    4              0.000011 if exists('&ofu')
    4              0.000007   if &ofu
                                " Do not keep track of previous omnifunc if it was not set in the first
                                " place
                                let b:prevofu=&ofu
    4              0.000002   endif
    4              0.000009   setl omnifunc=styledcomplete#CompleteSC
    4              0.000004 endif

SCRIPT  /home/max/.local/share/nvim/plugged/vim-javascript/indent/javascript.vim
Sourced 4 times
Total time:   0.000439
 Self time:   0.000439

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Javascript
                            " Maintainer: Chris Paul ( https://github.com/bounceme )
                            " URL: https://github.com/pangloss/vim-javascript
                            " Last Change: December 4, 2017
                            
                            " Only load this indent file when no other was loaded.
    4              0.000009 if exists('b:did_indent')
                              finish
    4              0.000002 endif
    4              0.000006 let b:did_indent = 1
                            
                            " Now, set up our indentation expression and keys that trigger it.
    4              0.000009 setlocal indentexpr=GetJavascriptIndent()
    4              0.000040 setlocal autoindent nolisp nosmartindent
    4              0.000009 setlocal indentkeys+=0],0)
                            " Testable with something like:
                            " vim  -eNs "+filetype plugin indent on" "+syntax on" "+set ft=javascript" \
                            "       "+norm! gg=G" '+%print' '+:q!' testfile.js \
                            "       | diff -uBZ testfile.js -
                            
    4              0.000009 let b:undo_indent = 'setlocal indentexpr< smartindent< autoindent< indentkeys<'
                            
                            " Only define the function once.
    4              0.000009 if exists('*GetJavascriptIndent')
    3              0.000002   finish
    1              0.000001 endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
                            " indent correctly if inside <script>
                            " vim/vim@690afe1 for the switch from cindent
                            " overridden with b:html_indent_script1
    1              0.000009 call extend(g:,{'html_indent_script1': 'inc'},'keep')
                            
                            " Regex of syntax group names that are or delimit string or are comments.
    1              0.000006 let s:bvars = {
                                  \ 'syng_strcom': 'string\|comment\|regex\|special\|doc\|template\%(braces\)\@!',
                                  \ 'syng_str': 'string\|template\|special' }
                            " template strings may want to be excluded when editing graphql:
                            " au! Filetype javascript let b:syng_str = '^\%(.*template\)\@!.*string\|special'
                            " au! Filetype javascript let b:syng_strcom = '^\%(.*template\)\@!.*string\|comment\|regex\|special\|doc'
                            
    1              0.000003 function s:GetVars()
                              call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')
                            endfunction
                            
                            " Get shiftwidth value
    1              0.000003 if exists('*shiftwidth')
    1              0.000002   function s:sw()
                                return shiftwidth()
                              endfunction
                            else
                              function s:sw()
                                return &l:shiftwidth ? &l:shiftwidth : &l:tabstop
                              endfunction
    1              0.000001 endif
                            
                            " Performance for forwards search(): start search at pos rather than masking
                            " matches before pos.
    1              0.000005 let s:z = has('patch-7.4.984') ? 'z' : ''
                            
                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000003 let s:skip_expr = "s:SynAt(line('.'),col('.')) =~? b:syng_strcom"
    1              0.000004 let s:in_comm = s:skip_expr[:-14] . "'comment\\|doc'"
                            
    1              0.000003 let s:rel = has('reltime')
                            " searchpair() wrapper
    1              0.000001 if s:rel
    1              0.000003   function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)
                              endfunction
                            else
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1)
                              endfunction
    1              0.000001 endif
                            
    1              0.000002 function s:SynAt(l,c)
                              let byte = line2byte(a:l) + a:c - 1
                              let pos = index(s:synid_cache[0], byte)
                              if pos == -1
                                let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
                              endif
                              return s:synid_cache[1][pos]
                            endfunction
                            
    1              0.000002 function s:ParseCino(f)
                              let [s, n, divider] = [strridx(&cino, a:f)+1, '', 0]
                              while s && &cino[ s ] =~ '[^,]'
                                if &cino[ s ] == '.'
                                  let divider = 1
                                elseif &cino[ s ] ==# 's'
                                  if n !~ '\d'
                                    return n . s:sw() + 0
                                  endif
                                  let n = str2nr(n) * s:sw()
                                  break
                                else
                                  let [n, divider] .= [&cino[ s ], 0]
                                endif
                                let s += 1
                              endwhile
                              return str2nr(n) / max([divider, 1])
                            endfunction
                            
                            " Optimized {skip} expr, only callable from the search loop which
                            " GetJavascriptIndent does to find the containing [[{(] (side-effects)
    1              0.000002 function s:SkipFunc()
                              if s:top_col == 1
                                throw 'out of bounds'
                              elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
                              elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
                              elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
                              else
                                let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
                              endif
                              let [s:looksyn, s:top_col] = getpos('.')[1:2]
                            endfunction
                            
    1              0.000002 function s:AlternatePair()
                              let [pat, l:for] = ['[][(){};]', 2]
                              while s:SearchLoop(pat,'bW','s:SkipFunc()')
                                if s:LookingAt() == ';'
                                  if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
                                  else
                                    let [pat, l:for] = ['[{}();]', l:for - 1]
                                  endif
                                else
                                  let idx = stridx('])}',s:LookingAt())
                                  if idx == -1
                                    return
                                  elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
                                  endif
                                endif
                              endwhile
                              throw 'out of bounds'
                            endfunction
                            
    1              0.000002 function s:Nat(int)
                              return a:int * (a:int > 0)
                            endfunction
                            
    1              0.000001 function s:LookingAt()
                              return getline('.')[col('.')-1]
                            endfunction
                            
    1              0.000001 function s:Token()
                              return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()
                            endfunction
                            
    1              0.000001 function s:PreviousToken(...)
                              let [l:pos, tok] = [getpos('.'), '']
                              if search('\m\k\{1,}\|\S','ebW')
                                if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
                                else
                                  let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
                                  if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
                                  else
                                    let tok = s:Token()
                                  endif
                                endif
                              endif
                              return tok
                            endfunction
                            
    1              0.000002 function s:Pure(f,...)
                              return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")
                            endfunction
                            
    1              0.000002 function s:SearchLoop(pat,flags,expr)
                              return s:GetPair(a:pat,'\_$.',a:flags,a:expr)
                            endfunction
                            
    1              0.000001 function s:ExprCol()
                              if getline('.')[col('.')-2] == ':'
                                return 1
                              endif
                              let bal = 0
                              while s:SearchLoop('[{}?:]','bW',s:skip_expr)
                                if s:LookingAt() == ':'
                                  let bal -= !search('\m:\%#','bW')
                                elseif s:LookingAt() == '?'
                                  if getline('.')[col('.'):col('.')+1] =~ '^\.\d\@!'
                                    " ?. conditional chain, not ternary start
                                  elseif !bal
                                    return 1
                                  else
                                    let bal += 1
                                  endif
                                elseif s:LookingAt() == '{'
                                  return !s:IsBlock()
                                elseif !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                            endfunction
                            
                            " configurable regexes that define continuation lines, not including (, {, or [.
    1              0.000007 let s:opfirst = '^' . get(g:,'javascript_opfirst',
                                  \ '\C\%([<>=,.?^%|/&]\|\([-:+]\)\1\@!\|\*\+\|!=\|in\%(stanceof\)\=\>\)')
    1              0.000006 let s:continuation = get(g:,'javascript_continuation',
                                  \ '\C\%([<=,.~!?/*^%|&:]\|+\@<!+\|-\@<!-\|=\@<!>\|\<\%(typeof\|new\|delete\|void\|in\|instanceof\|await\)\)') . '$'
                            
    1              0.000001 function s:Continues()
                              let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
                              if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
                              elseif tok !~ '[/>]'
                                return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')
                            endfunction
                            
                            " Check if line 'lnum' has a balanced amount of parentheses.
    1              0.000002 function s:Balanced(lnum,line)
                              let l:open = 0
                              let pos = match(a:line, '[][(){}]')
                              while pos != -1
                                if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
                                  let l:open += matchend(a:line[pos],'[[({]')
                                  if l:open < 0
                                    return
                                  endif
                                endif
                                let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ?
                                      \ '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
                              endwhile
                              return !l:open
                            endfunction
                            
    1              0.000001 function s:OneScope()
                              if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
                                let tok = s:PreviousToken()
                                return (count(split('for if let while with'),tok) ||
                                      \ tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') &&
                                      \ s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
                              elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
                              elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                return s:PreviousToken() != ')' || s:GetPair('(', ')', 'bW', s:skip_expr)
                              endif
                            endfunction
                            
    1              0.000001 function s:DoWhile()
                              let cpos = searchpos('\m\<','cbW')
                              while s:SearchLoop('\C[{}]\|\<\%(do\|while\)\>','bW',s:skip_expr)
                                if s:LookingAt() =~ '\a'
                                  if s:Pure('s:IsBlock')
                                    if s:LookingAt() ==# 'd'
                                      return 1
                                    endif
                                    break
                                  endif
                                elseif s:LookingAt() != '}' || !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                              call call('cursor',cpos)
                            endfunction
                            
                            " returns total offset from braceless contexts. 'num' is the lineNr which
                            " encloses the entire context, 'cont' if whether a:firstline is a continued
                            " expression, which could have started in a braceless context
    1              0.000002 function s:IsContOne(cont)
                              let [l:num, pind] = b:js_cache[1] ?
                                    \ [b:js_cache[1], indent(b:js_cache[1]) + s:sw()] : [1,0]
                              let [ind, b_l] = [indent('.') + !a:cont, 0]
                              while line('.') > l:num && ind > pind || line('.') == l:num
                                if indent('.') < ind && s:OneScope()
                                  let b_l += 1
                                elseif !a:cont || b_l || ind < indent(a:firstline)
                                  break
                                else
                                  call cursor(0,1)
                                endif
                                let ind = min([ind, indent('.')])
                                if s:PreviousToken() is ''
                                  break
                                endif
                              endwhile
                              return b_l
                            endfunction
                            
    1              0.000001 function s:IsSwitch()
                              return search(printf('\m\C\%%%dl\%%%dc%s',b:js_cache[1],b:js_cache[2],
                                    \ '{\_s*\%(\%(\/\/.*\_$\|\/\*\_.\{-}\*\/\)\@>\_s*\)*\%(case\|default\)\>'),'nW'.s:z)
                            endfunction
                            
                            " https://github.com/sweet-js/sweet.js/wiki/design#give-lookbehind-to-the-reader
    1              0.000001 function s:IsBlock()
                              let tok = s:PreviousToken()
                              if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
                              elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||"
                                        \ ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof')
                                      \ ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
                              elseif tok == '>'
                                return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif
                            endfunction
                            
    1              0.000001 function GetJavascriptIndent()
                              call s:GetVars()
                              let s:synid_cache = [[],[]]
                              let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
                              let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
                              if s:stack[-1] =~? 'comment\|doc'
                                if l:line !~ '^\s*\/[/*]'
                                  return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
                                endif
                              elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
                              endif
                            
                              let nest = get(get(b:,'hi_indent',{}),'blocklnr')
                              let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
                              call cursor(v:lnum,1)
                              if s:PreviousToken() is ''
                                return
                              endif
                              let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
                            
                              let l:line = substitute(l:line,'^\s*','','')
                              let l:line_s = l:line[0]
                              if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
                              if l:line =~ '^\/[/*]'
                                let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
                              call cursor(v:lnum,1)
                              let idx = index([']',')','}'],l:line[0])
                              if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum ||
                                    \ b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
                              else
                                let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0,
                                      \ max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
                                try
                                  if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                  elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
                                      return indent(l:lnum)
                                    endif
                                  else
                                    call s:AlternatePair()
                                  endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
                                endtry
                                let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
                              endif
                            
                              let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
                              let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
                              if !num || s:LookingAt() == '{' && s:IsBlock()
                                let ilnum = line('.')
                                if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
                                endif
                                if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, lcol)
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum,
                                        \ 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' &&
                                        \ s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) &&
                                        \ s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) &&
                                        \ (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' &&
                                        \ s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, lcol)
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
                                endif
                              elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' &&
                                    \ (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
                              endif
                            
                              " main return
                              if l:line =~ '^[])}]\|^|}'
                                if l:line_s == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
                              elseif num
                                return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              elseif nest
                                return indent(nextnonblank(nest+1)) + b_l + is_op
                              endif
                              return b_l + is_op
                            endfunction
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/indent/javascript.vim
Sourced 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Javascript
                            " Maintainer: Chris Paul ( https://github.com/bounceme )
                            " URL: https://github.com/pangloss/vim-javascript
                            " Last Change: December 4, 2017
                            
                            " Only load this indent file when no other was loaded.
    4              0.000009 if exists('b:did_indent')
    4              0.000003   finish
                            endif
                            let b:did_indent = 1
                            
                            " Now, set up our indentation expression and keys that trigger it.
                            setlocal indentexpr=GetJavascriptIndent()
                            setlocal autoindent nolisp nosmartindent
                            setlocal indentkeys+=0],0)
                            " Testable with something like:
                            " vim  -eNs "+filetype plugin indent on" "+syntax on" "+set ft=javascript" \
                            "       "+norm! gg=G" '+%print' '+:q!' testfile.js \
                            "       | diff -uBZ testfile.js -
                            
                            let b:undo_indent = 'setlocal indentexpr< smartindent< autoindent< indentkeys<'
                            
                            " Only define the function once.
                            if exists('*GetJavascriptIndent')
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " indent correctly if inside <script>
                            " vim/vim@690afe1 for the switch from cindent
                            " overridden with b:html_indent_script1
                            call extend(g:,{'html_indent_script1': 'inc'},'keep')
                            
                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:bvars = {
                                  \ 'syng_strcom': 'string\|comment\|regex\|special\|doc\|template\%(braces\)\@!',
                                  \ 'syng_str': 'string\|template\|special' }
                            " template strings may want to be excluded when editing graphql:
                            " au! Filetype javascript let b:syng_str = '^\%(.*template\)\@!.*string\|special'
                            " au! Filetype javascript let b:syng_strcom = '^\%(.*template\)\@!.*string\|comment\|regex\|special\|doc'
                            
                            function s:GetVars()
                              call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')
                            endfunction
                            
                            " Get shiftwidth value
                            if exists('*shiftwidth')
                              function s:sw()
                                return shiftwidth()
                              endfunction
                            else
                              function s:sw()
                                return &l:shiftwidth ? &l:shiftwidth : &l:tabstop
                              endfunction
                            endif
                            
                            " Performance for forwards search(): start search at pos rather than masking
                            " matches before pos.
                            let s:z = has('patch-7.4.984') ? 'z' : ''
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "s:SynAt(line('.'),col('.')) =~? b:syng_strcom"
                            let s:in_comm = s:skip_expr[:-14] . "'comment\\|doc'"
                            
                            let s:rel = has('reltime')
                            " searchpair() wrapper
                            if s:rel
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)
                              endfunction
                            else
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1)
                              endfunction
                            endif
                            
                            function s:SynAt(l,c)
                              let byte = line2byte(a:l) + a:c - 1
                              let pos = index(s:synid_cache[0], byte)
                              if pos == -1
                                let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
                              endif
                              return s:synid_cache[1][pos]
                            endfunction
                            
                            function s:ParseCino(f)
                              let [divider, n, cstr] = [0] + matchlist(&cino,
                                    \ '\%(.*,\)\=\%(\%d'.char2nr(a:f).'\(-\)\=\([.s0-9]*\)\)\=')[1:2]
                              for c in split(cstr,'\zs')
                                if c == '.' && !divider
                                  let divider = 1
                                elseif c ==# 's'
                                  if n !~ '\d'
                                    return n . s:sw() + 0
                                  endif
                                  let n = str2nr(n) * s:sw()
                                  break
                                else
                                  let [n, divider] .= [c, 0]
                                endif
                              endfor
                              return str2nr(n) / max([str2nr(divider),1])
                            endfunction
                            
                            " Optimized {skip} expr, only callable from the search loop which
                            " GetJavascriptIndent does to find the containing [[{(] (side-effects)
                            function s:SkipFunc()
                              if s:top_col == 1
                                throw 'out of bounds'
                              elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
                              elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
                              elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
                              else
                                let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
                              endif
                              let [s:looksyn, s:top_col] = getpos('.')[1:2]
                            endfunction
                            
                            function s:AlternatePair()
                              let [pat, l:for] = ['[][(){};]', 2]
                              while s:SearchLoop(pat,'bW','s:SkipFunc()')
                                if s:LookingAt() == ';'
                                  if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
                                  else
                                    let [pat, l:for] = ['[{}();]', l:for - 1]
                                  endif
                                else
                                  let idx = stridx('])}',s:LookingAt())
                                  if idx == -1
                                    return
                                  elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
                                  endif
                                endif
                              endwhile
                              throw 'out of bounds'
                            endfunction
                            
                            function s:Nat(int)
                              return a:int * (a:int > 0)
                            endfunction
                            
                            function s:LookingAt()
                              return getline('.')[col('.')-1]
                            endfunction
                            
                            function s:Token()
                              return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()
                            endfunction
                            
                            function s:PreviousToken(...)
                              let [l:pos, tok] = [getpos('.'), '']
                              if search('\m\k\{1,}\|\S','ebW')
                                if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
                                else
                                  let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
                                  if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
                                  else
                                    let tok = s:Token()
                                  endif
                                endif
                              endif
                              return tok
                            endfunction
                            
                            function s:Pure(f,...)
                              return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")
                            endfunction
                            
                            function s:SearchLoop(pat,flags,expr)
                              return s:GetPair(a:pat,'\_$.',a:flags,a:expr)
                            endfunction
                            
                            function s:ExprCol()
                              if getline('.')[col('.')-2] == ':'
                                return 1
                              endif
                              let bal = 0
                              while s:SearchLoop('[{}?:]','bW',s:skip_expr)
                                if s:LookingAt() == ':'
                                  if getline('.')[col('.')-2] == ':'
                                    call cursor(0,col('.')-1)
                                    continue
                                  endif
                                  let bal -= 1
                                elseif s:LookingAt() == '?'
                                  if getline('.')[col('.'):col('.')+1] =~ '^\.\d\@!'
                                    continue
                                  elseif !bal
                                    return 1
                                  endif
                                  let bal += 1
                                elseif s:LookingAt() == '{'
                                  return !s:IsBlock()
                                elseif !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                            endfunction
                            
                            " configurable regexes that define continuation lines, not including (, {, or [.
                            let s:opfirst = '^' . get(g:,'javascript_opfirst',
                                  \ '\C\%([<>=,.?^%|/&]\|\([-:+]\)\1\@!\|\*\+\|!=\|in\%(stanceof\)\=\>\)')
                            let s:continuation = get(g:,'javascript_continuation',
                                  \ '\C\%([<=,.~!?/*^%|&:]\|+\@<!+\|-\@<!-\|=\@<!>\|\<\%(typeof\|new\|delete\|void\|in\|instanceof\|await\)\)') . '$'
                            
                            function s:Continues()
                              let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
                              if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
                              elseif tok !~ '[/>]'
                                return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')
                            endfunction
                            
                            " Check if line 'lnum' has a balanced amount of parentheses.
                            function s:Balanced(lnum,line)
                              let l:open = 0
                              let pos = match(a:line, '[][(){}]')
                              while pos != -1
                                if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
                                  let l:open += match(' ' . a:line[pos],'[[({]')
                                  if l:open < 0
                                    return
                                  endif
                                endif
                                let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ?
                                      \ '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
                              endwhile
                              return !l:open
                            endfunction
                            
                            function s:OneScope()
                              if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
                                let tok = s:PreviousToken()
                                return (count(split('for if let while with'),tok) ||
                                      \ tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') &&
                                      \ s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
                              elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
                              elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                if s:PreviousToken() == ')'
                                  return s:GetPair('(', ')', 'bW', s:skip_expr)
                                endif
                                return 1
                              endif
                            endfunction
                            
                            function s:DoWhile()
                              let cpos = searchpos('\m\<','cbW')
                              while s:SearchLoop('\C[{}]\|\<\%(do\|while\)\>','bW',s:skip_expr)
                                if s:LookingAt() =~ '\a'
                                  if s:Pure('s:IsBlock')
                                    if s:LookingAt() ==# 'd'
                                      return 1
                                    endif
                                    break
                                  endif
                                elseif s:LookingAt() != '}' || !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                              call call('cursor',cpos)
                            endfunction
                            
                            " returns total offset from braceless contexts. 'num' is the lineNr which
                            " encloses the entire context, 'cont' if whether a:firstline is a continued
                            " expression, which could have started in a braceless context
                            function s:IsContOne(cont)
                              let [l:num, b_l] = [b:js_cache[1] + !b:js_cache[1], 0]
                              let pind = b:js_cache[1] ? indent(b:js_cache[1]) + s:sw() : 0
                              let ind = indent('.') + !a:cont
                              while line('.') > l:num && ind > pind || line('.') == l:num
                                if indent('.') < ind && s:OneScope()
                                  let b_l += 1
                                elseif !a:cont || b_l || ind < indent(a:firstline)
                                  break
                                else
                                  call cursor(0,1)
                                endif
                                let ind = min([ind, indent('.')])
                                if s:PreviousToken() is ''
                                  break
                                endif
                              endwhile
                              return b_l
                            endfunction
                            
                            function s:IsSwitch()
                              call call('cursor',b:js_cache[1:])
                              return search('\m\C\%#.\_s*\%(\%(\/\/.*\_$\|\/\*\_.\{-}\*\/\)\@>\_s*\)*\%(case\|default\)\>','nWc'.s:z)
                            endfunction
                            
                            " https://github.com/sweet-js/sweet.js/wiki/design#give-lookbehind-to-the-reader
                            function s:IsBlock()
                              let tok = s:PreviousToken()
                              if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
                              elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||"
                                        \ ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof')
                                      \ ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
                              elseif tok == '>'
                                return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif
                            endfunction
                            
                            function GetJavascriptIndent()
                              call s:GetVars()
                              let s:synid_cache = [[],[]]
                              let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
                              let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
                              if s:stack[-1] =~? 'comment\|doc'
                                if l:line =~ '^\s*\*'
                                  return cindent(v:lnum)
                                elseif l:line !~ '^\s*\/[/*]'
                                  return -1
                                endif
                              elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
                              endif
                            
                              let s:l1 = max([0,prevnonblank(v:lnum) - (s:rel ? 2000 : 1000),
                                    \ get(get(b:,'hi_indent',{}),'blocklnr')])
                              call cursor(v:lnum,1)
                              if s:PreviousToken() is ''
                                return
                              endif
                              let [l:lnum, pline] = [line('.'), getline('.')[:col('.')-1]]
                            
                              let l:line = substitute(l:line,'^\s*','','')
                              let l:line_raw = l:line
                              if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
                              if l:line =~ '^\/[/*]'
                                let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
                              call cursor(v:lnum,1)
                              let idx = index([']',')','}'],l:line[0])
                              if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum ||
                                    \ b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
                              else
                                let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0,
                                      \ max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
                                try
                                  if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                  elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    call s:GetPair('{','}','bW','s:SkipFunc()')
                                  else
                                    call s:AlternatePair()
                                  endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
                                endtry
                                let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
                              endif
                            
                              let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
                              let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
                              if !num || s:LookingAt() == '{' && s:IsBlock()
                                let ilnum = line('.')
                                if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
                                endif
                                if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, len(pline))
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum,
                                        \ 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' &&
                                        \ s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) &&
                                        \ s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) &&
                                        \ (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' &&
                                        \ s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, len(pline))
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
                                endif
                              elseif idx.s:LookingAt().&cino =~ '^-1(.*(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m\S','W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
                              endif
                            
                              " main return
                              if l:line =~ '^[])}]\|^|}'
                                if l:line_raw[0] == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
                              elseif num
                                return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              endif
                              return b_l + is_op
                            endfunction
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /home/max/.local/share/nvim/plugged/vim-styled-components/after/indent/javascript.vim
Sourced 4 times
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:   styled-components (js/ts)
                            " Maintainer: Karl Fleischmann <fleischmann.karl@gmail.com>
                            " URL:        https://github.com/styled-components/vim-styled-components
                            
                            " initialize variable to check, if the indentation expression is run
                            " multiple times in a row, which indicates an infinite recursion
    4              0.000007 let s:is_recursion = 0
                            
                            " store current indentexpr for later
    4              0.000008 let b:js_ts_indent=&indentexpr
                            
                            " set indentexpr for this filetype (styled-components)
    4              0.000009 setlocal indentexpr=GetStyledIndent()
                            
                            " add the following keys to trigger reindenting, when in insert mode
                            " - *;    - Indent and insert on press of ';' key.
                            " - *<:>  - Indent and insert on press of ':' key.
    4              0.000009 set indentkeys+=*;,*<:>,*<Return>
                            
    4              0.000008 fu! s:GetSyntaxNames(lnum, cnum)
                              return map(synstack(a:lnum, a:cnum), 'synIDattr(v:val, "name")')
                            endfu
                            
                            " re-implement SynSOL of vim-jsx
                            " TODO: add dependency to the readme and remove duplicate implementation
    4              0.000005 fu! s:SynSOL(lnum)
                              return s:GetSyntaxNames(a:lnum, 1)
                            endfu
                            
                            " re-implement SynEOL of vim-jsx
                            " TODO: add dependency to the readme and remove duplicate implementation
    4              0.000005 fu! s:SynEOL(lnum, offset)
                              let l:lnum = prevnonblank(a:lnum)
                              let l:col = strlen(getline(l:lnum))
                            
                              return s:GetSyntaxNames(l:lnum, l:col + a:offset)
                            endfu
                            
                            
                            "" Return whether the current line is a jsTemplateString
    4              0.000005 fu! s:IsStyledDefinition(lnum)
                              " iterate through all syntax items in the given line
                              for item in s:SynSOL(a:lnum)
                                " if syntax-item is a jsTemplateString return 1 - true
                                " `==#` is a match case comparison of the item
                                if item ==# 'styledDefinition'
                                  return 1
                                endif
                              endfor
                            
                              " fallback to 0 - false
                              return 0
                            endfu
                            
                            "" Count occurences of `str` at the beginning of the given `lnum` line
    4              0.000006 fu! s:CountOccurencesInSOL(lnum, str)
                              let l:occurence = 0
                            
                              " iterate through all items in the given line
                              for item in s:SynSOL(a:lnum)
                                " if the syntax-item equals the given str increment the counter
                                " `==?` is a case isensitive equal operation
                                if item ==? a:str
                                  let l:occurence += 1
                                endif
                              endfor
                            
                              " return the accumulated count of occurences
                              return l:occurence
                            endfu
                            
                            "" Count occurences of `str` at the end of the given `lnum` line
    4              0.000006 fu! s:CountOccurencesInEOL(lnum, str, offset)
                              let l:occurence = 0
                            
                              " iterate through all items in the given line
                              for item in s:SynEOL(a:lnum, a:offset)
                                " if the syntax-item equals the given str increment the counter
                                " `==?` is a case insensitive equal operation
                                if item == a:str
                                  let l:occurence += 1
                                endif
                              endfor
                            
                              " return the accumulated count of occurences
                              return l:occurence
                            endfu
                            
                            "" Get the indentation of the current line
    4              0.000004 fu! GetStyledIndent()
                              if s:IsStyledDefinition(v:lnum)
                                let l:baseIndent = 0
                            
                                " find last non-styled line
                                let l:cnum = v:lnum
                                while s:IsStyledDefinition(l:cnum)
                                  let l:cnum -= 1
                                endwhile
                            
                                " get indentation of the last non-styled line as base indentation
                                let l:baseIndent = indent(l:cnum)
                            
                                " incrementally build indentation based on current indentation
                                " - one shiftwidth for the styled definition region
                                " - one shiftwidth per open nested definition region
                                let l:styledIndent = &sw
                                let l:styledIndent += min([
                                      \ s:CountOccurencesInSOL(v:lnum, 'styledNestedRegion'),
                                      \ s:CountOccurencesInEOL(v:lnum, 'styledNestedRegion', 0)
                                      \ ]) * &sw
                            
                                " decrease indentation by one shiftwidth, if the styled definition
                                " region ends on the current line
                                " - either directly via styled definition region, or
                                " - if the very last
                                if s:CountOccurencesInEOL(v:lnum, 'styledDefinition', 1) == 0
                                  let l:styledIndent -= &sw
                                endif
                            
                                " return the base indentation
                                " (for nested styles inside classes/objects/etc.) plus the actual
                                " indentation inside the styled definition region
                                return l:baseIndent + l:styledIndent
                              elseif len(b:js_ts_indent)
                                let l:result = 0
                                let l:offset = 0
                            
                                " increase indentation by one shiftwidth, if the last line ended on a
                                " styledXmlRegion and this line does not continue with it
                                " this is a fix for an incorrectly indented xml prop after a
                                " glamor-styled styledXmlRegion
                                if s:CountOccurencesInEOL(v:lnum-1, 'styledXmlRegion', 0) == 1 &&
                                      \ s:CountOccurencesInSOL(v:lnum, 'styledXmlRegion') == 0
                                  let l:offset = &sw
                                endif
                            
                                " make sure `GetStyledIndent` and `GetJsxIndent` don't infinitely
                                " recurse by incrementing a counter variable, before evaluating the
                                " stored indent expression
                                if s:is_recursion == 0
                                  let s:is_recursion = 1
                                  let l:result = eval(b:js_ts_indent)
                                endif
                            
                                " `is_recursion` being 0 at this point indicates, that
                                " `eval(b:js_ts_indent)` did itself evaluate it's stored indentexpr
                                " and thus it can be assumed, that the current line should be
                                " indented as JS/TS
                                if s:is_recursion == 0
                                  " use one of existing indent expressions if available
                                  " fallback to cindent, if not
                                  if exists('*GetTsxIndent')
                                    let l:result = GetTsxIndent()
                                  elseif exists('*GetTypescriptIndent')
                                    let l:result = GetTypescriptIndent()
                                  elseif exists('*GetJsxIndent')
                                    let l:result = GetJsxIndent()
                                  elseif exists('*GetJsIndent')
                                    let l:result = GetJsIndent()
                                  elseif exists('*GetJavascriptIndent')
                                    let l:result = GetJavascriptIndent()
                                  else
                                    let l:result = cindent(v:lnum)
                                  endif
                                endif
                            
                                " reset `is_recursion` counter and return the indentation value
                                let s:is_recursion = 0
                                return l:result + l:offset
                              endif
                            
                              " if all else fails indent according to C-syntax
                              return cindent(v:lnum)
                            endfu

SCRIPT  /home/max/.local/share/nvim/plugged/vim-javascript/syntax/javascript.vim
Sourced 4 times
Total time:   0.009423
 Self time:   0.009423

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    4              0.000010 if !exists("main_syntax")
    4              0.000006   if version < 600
                                syntax clear
    4              0.000008   elseif exists("b:current_syntax")
                                finish
    4              0.000002   endif
    4              0.000012   let main_syntax = 'javascript'
    4              0.000002 endif
                            
                            " Dollar sign is permitted anywhere in an identifier
    4              0.000014 if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
    4              0.000025   syntax iskeyword @,48-57,_,192-255,$
                            else
                              setlocal iskeyword+=$
    4              0.000002 endif
                            
    4              0.000005 syntax sync fromstart
                            " TODO: Figure out what type of casing I need
                            " syntax case ignore
    4              0.000003 syntax case match
                            
    4              0.000032 syntax match   jsNoise          /[:,;]/
    4              0.000077 syntax match   jsDot            /\./ skipwhite skipempty nextgroup=jsObjectProp,jsFuncCall,jsPrototype,jsTaggedTemplate
    4              0.000016 syntax match   jsObjectProp     contained /\<\K\k*/
    4              0.000015 syntax match   jsFuncCall       /\<\K\k*\ze\s*(/
    4              0.000016 syntax match   jsParensError    /[)}\]]/
                            
                            " Program Keywords
    4              0.000064 syntax keyword jsStorageClass   const var let skipwhite skipempty nextgroup=jsDestructuringBlock,jsDestructuringArray,jsVariableDef
    4              0.000028 syntax match   jsVariableDef    contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFlowDefinition
    4              0.000026 syntax keyword jsOperatorKeyword delete instanceof typeof void new in of skipwhite skipempty nextgroup=@jsExpression
    4              0.000021 syntax match   jsOperator       "[-!|&+<>=%/*~^]" skipwhite skipempty nextgroup=@jsExpression
    4              0.000015 syntax match   jsOperator       /::/ skipwhite skipempty nextgroup=@jsExpression
    4              0.000014 syntax keyword jsBooleanTrue    true
    4              0.000013 syntax keyword jsBooleanFalse   false
                            
                            " Modules
    4              0.000066 syntax keyword jsImport                       import skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup,jsFlowImportType
    4              0.000073 syntax keyword jsExport                       export skipwhite skipempty nextgroup=@jsAll,jsModuleGroup,jsExportDefault,jsModuleAsterisk,jsModuleKeyword,jsFlowTypeStatement
    4              0.000053 syntax match   jsModuleKeyword      contained /\<\K\k*/ skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    4              0.000014 syntax keyword jsExportDefault      contained default skipwhite skipempty nextgroup=@jsExpression
    4              0.000042 syntax keyword jsExportDefaultGroup contained default skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    4              0.000043 syntax match   jsModuleAsterisk     contained /\*/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAs,jsFrom
    4              0.000031 syntax keyword jsModuleAs           contained as skipwhite skipempty nextgroup=jsModuleKeyword,jsExportDefaultGroup
    4              0.000023 syntax keyword jsFrom               contained from skipwhite skipempty nextgroup=jsString
    4              0.000056 syntax match   jsModuleComma        contained /,/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAsterisk,jsModuleGroup,jsFlowTypeKeyword
                            
                            " Strings, Templates, Numbers
    4              0.000060 syntax region  jsString           start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+  contains=jsSpecial extend
    4              0.000055 syntax region  jsTemplateString   start=+`+  skip=+\\`+  end=+`+     contains=jsTemplateExpression,jsSpecial extend
    4              0.000026 syntax match   jsTaggedTemplate   /\<\K\k*\ze`/ nextgroup=jsTemplateString
    4              0.000032 syntax match   jsNumber           /\c\<\%(\d\+\%(e[+-]\=\d\+\)\=\|0b[01]\+\|0o\o\+\|0x\x\+\)\>/
    4              0.000010 syntax keyword jsNumber           Infinity
    4              0.000026 syntax match   jsFloat            /\c\<\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%(e[+-]\=\d\+\)\=\>/
                            
                            " Regular Expressions
    4              0.000027 syntax match   jsSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
    4              0.000034 syntax region  jsTemplateExpression contained matchgroup=jsTemplateBraces start=+${+ end=+}+ contains=@jsExpression keepend
    4              0.000039 syntax region  jsRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=jsSpecial extend
    4              0.000018 syntax match   jsRegexpBoundary     contained "\v\c[$^]|\\b"
    4              0.000018 syntax match   jsRegexpBackRef      contained "\v\\[1-9]\d*"
    4              0.000025 syntax match   jsRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
    4              0.000016 syntax match   jsRegexpOr           contained "|"
    4              0.000017 syntax match   jsRegexpMod          contained "\v\(\?[:=!>]"lc=1
    4              0.000057 syntax region  jsRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=jsRegexpCharClass,@jsRegexpSpecial keepend
    4              0.000097 syntax region  jsRegexpString   start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+ contains=jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial oneline keepend extend
    4              0.000067 syntax cluster jsRegexpSpecial    contains=jsSpecial,jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
                            
                            " Objects
    4              0.000034 syntax match   jsObjectShorthandProp contained /\<\k*\ze\s*/ skipwhite skipempty nextgroup=jsObjectSeparator
    4              0.000044 syntax match   jsObjectKey         contained /\<\k*\ze\s*:/ contains=jsFunctionKey skipwhite skipempty nextgroup=jsObjectValue
    4              0.000055 syntax region  jsObjectKeyString   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial skipwhite skipempty nextgroup=jsObjectValue
    4              0.000057 syntax region  jsObjectKeyComputed contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsObjectValue,jsFuncArgs extend
    4              0.000016 syntax match   jsObjectSeparator   contained /,/
    4              0.000031 syntax region  jsObjectValue       contained matchgroup=jsObjectColon start=/:/ end=/[,}]\@=/ contains=@jsExpression extend
    4              0.000029 syntax match   jsObjectFuncName    contained /\<\K\k*\ze\_s*(/ skipwhite skipempty nextgroup=jsFuncArgs
    4              0.000017 syntax match   jsFunctionKey       contained /\<\K\k*\ze\s*:\s*function\>/
    4              0.000030 syntax match   jsObjectMethodType  contained /\<[gs]et\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsObjectFuncName
    4              0.000060 syntax region  jsObjectStringKey   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs,jsObjectValue
                            
    4              0.000036 exe 'syntax keyword jsNull      null             '.(exists('g:javascript_conceal_null')      ? 'conceal cchar='.g:javascript_conceal_null       : '')
    4              0.000036 exe 'syntax keyword jsReturn    return contained '.(exists('g:javascript_conceal_return')    ? 'conceal cchar='.g:javascript_conceal_return     : '').' skipwhite nextgroup=@jsExpression'
    4              0.000027 exe 'syntax keyword jsUndefined undefined        '.(exists('g:javascript_conceal_undefined') ? 'conceal cchar='.g:javascript_conceal_undefined  : '')
    4              0.000025 exe 'syntax keyword jsNan       NaN              '.(exists('g:javascript_conceal_NaN')       ? 'conceal cchar='.g:javascript_conceal_NaN        : '')
    4              0.000024 exe 'syntax keyword jsPrototype prototype        '.(exists('g:javascript_conceal_prototype') ? 'conceal cchar='.g:javascript_conceal_prototype  : '')
    4              0.000025 exe 'syntax keyword jsThis      this             '.(exists('g:javascript_conceal_this')      ? 'conceal cchar='.g:javascript_conceal_this       : '')
    4              0.000026 exe 'syntax keyword jsSuper     super  contained '.(exists('g:javascript_conceal_super')     ? 'conceal cchar='.g:javascript_conceal_super      : '')
                            
                            " Statement Keywords
    4              0.000044 syntax match   jsBlockLabel              /\<\K\k*\s*::\@!/    contains=jsNoise skipwhite skipempty nextgroup=jsBlock
    4              0.000018 syntax match   jsBlockLabelKey contained /\<\K\k*\ze\s*\_[;]/
    4              0.000016 syntax keyword jsStatement     contained with yield debugger
    4              0.000028 syntax keyword jsStatement     contained break continue skipwhite skipempty nextgroup=jsBlockLabelKey
    4              0.000026 syntax keyword jsConditional            if              skipwhite skipempty nextgroup=jsParenIfElse
    4              0.000034 syntax keyword jsConditional            else            skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock
    4              0.000021 syntax keyword jsConditional            switch          skipwhite skipempty nextgroup=jsParenSwitch
    4              0.000037 syntax keyword jsRepeat                 while for       skipwhite skipempty nextgroup=jsParenRepeat,jsForAwait
    4              0.000024 syntax keyword jsDo                     do              skipwhite skipempty nextgroup=jsRepeatBlock
    4              0.000063 syntax region  jsSwitchCase   contained matchgroup=jsLabel start=/\<\%(case\|default\)\>/ end=/:\@=/ contains=@jsExpression,jsLabel skipwhite skipempty nextgroup=jsSwitchColon keepend
    4              0.000026 syntax keyword jsTry                    try             skipwhite skipempty nextgroup=jsTryCatchBlock
    4              0.000025 syntax keyword jsFinally      contained finally         skipwhite skipempty nextgroup=jsFinallyBlock
    4              0.000024 syntax keyword jsCatch        contained catch           skipwhite skipempty nextgroup=jsParenCatch
    4              0.000017 syntax keyword jsException              throw
    4              0.000012 syntax keyword jsAsyncKeyword           async await
    4              0.000026 syntax match   jsSwitchColon   contained /::\@!/        skipwhite skipempty nextgroup=jsSwitchBlock
                            
                            " Keywords
    4              0.000078 syntax keyword jsGlobalObjects     ArrayBuffer Array BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Boolean Buffer Collator DataView Date DateTimeFormat Function Intl Iterator JSON Map Set WeakMap WeakSet Math Number NumberFormat Object ParallelArray Promise Proxy Reflect RegExp String Symbol Uint8ClampedArray WebAssembly console document fetch window
    4              0.000016 syntax keyword jsGlobalNodeObjects  module exports global process __dirname __filename
    4              0.000026 syntax match   jsGlobalNodeObjects  /\<require\>/ containedin=jsFuncCall
    4              0.000019 syntax keyword jsExceptions         Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
    4              0.000019 syntax keyword jsBuiltins           decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
                            " DISCUSS: How imporant is this, really? Perhaps it should be linked to an error because I assume the keywords are reserved?
    4              0.000029 syntax keyword jsFutureKeys         abstract enum int short boolean interface byte long char final native synchronized float package throws goto private transient implements protected volatile double public
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 Objects
    4              0.000023 syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
    4              0.000008 syntax keyword jsExceptions     DOMException
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 CONSTANT
    4              0.000025 syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
    4              0.000102 syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                            
                            " DISCUSS: Should we really be special matching on these props?
                            " HTML events and internal variables
    4              0.000134 syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
                            
                            " Code blocks
    4              0.000047 syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold
    4              0.000044 syntax region  jsParen                        matchgroup=jsParens              start=/(/  end=/)/  contains=@jsExpression extend fold nextgroup=jsFlowDefinition
    4              0.000031 syntax region  jsParenDecorator     contained matchgroup=jsParensDecorator     start=/(/  end=/)/  contains=@jsAll extend fold
    4              0.000063 syntax region  jsParenIfElse        contained matchgroup=jsParensIfElse        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock,jsReturn extend fold
    4              0.000061 syntax region  jsParenRepeat        contained matchgroup=jsParensRepeat        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentRepeat,jsRepeatBlock,jsReturn extend fold
    4              0.000037 syntax region  jsParenSwitch        contained matchgroup=jsParensSwitch        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsSwitchBlock extend fold
    4              0.000041 syntax region  jsParenCatch         contained matchgroup=jsParensCatch         start=/(/  end=/)/  skipwhite skipempty nextgroup=jsTryCatchBlock extend fold
    4              0.000145 syntax region  jsFuncArgs           contained matchgroup=jsFuncParens          start=/(/  end=/)/  contains=jsFuncArgCommas,jsComment,jsFuncArgExpression,jsDestructuringBlock,jsDestructuringArray,jsRestExpression,jsFlowArgumentDef skipwhite skipempty nextgroup=jsCommentFunction,jsFuncBlock,jsFlowReturn extend fold
    4              0.000159 syntax region  jsClassBlock         contained matchgroup=jsClassBraces         start=/{/  end=/}/  contains=jsClassFuncName,jsClassMethodType,jsArrowFunction,jsArrowFuncArgs,jsComment,jsGenerator,jsDecorator,jsClassProperty,jsClassPropertyComputed,jsClassStringKey,jsAsyncKeyword,jsNoise extend fold
    4              0.000037 syntax region  jsFuncBlock          contained matchgroup=jsFuncBraces          start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    4              0.000037 syntax region  jsIfElseBlock        contained matchgroup=jsIfElseBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    4              0.000055 syntax region  jsTryCatchBlock      contained matchgroup=jsTryCatchBraces      start=/{/  end=/}/  contains=@jsAll,jsBlock skipwhite skipempty nextgroup=jsCatch,jsFinally extend fold
    4              0.000036 syntax region  jsFinallyBlock       contained matchgroup=jsFinallyBraces       start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    4              0.000045 syntax region  jsSwitchBlock        contained matchgroup=jsSwitchBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock,jsSwitchCase extend fold
    4              0.000036 syntax region  jsRepeatBlock        contained matchgroup=jsRepeatBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    4              0.000104 syntax region  jsDestructuringBlock contained matchgroup=jsDestructuringBraces start=/{/  end=/}/  contains=jsDestructuringProperty,jsDestructuringAssignment,jsDestructuringNoise,jsDestructuringPropertyComputed,jsSpreadExpression,jsComment nextgroup=jsFlowDefinition extend fold
    4              0.000105 syntax region  jsDestructuringArray contained matchgroup=jsDestructuringBraces start=/\[/ end=/\]/ contains=jsDestructuringPropertyValue,jsDestructuringNoise,jsDestructuringProperty,jsSpreadExpression,jsDestructuringBlock,jsDestructuringArray,jsComment nextgroup=jsFlowDefinition extend fold
    4              0.000161 syntax region  jsObject             contained matchgroup=jsObjectBraces        start=/{/  end=/}/  contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectShorthandProp,jsObjectSeparator,jsObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsDecorator,jsAsyncKeyword,jsTemplateString extend fold
    4              0.000036 syntax region  jsBlock                        matchgroup=jsBraces              start=/{/  end=/}/  contains=@jsAll,jsSpreadExpression extend fold
    4              0.000093 syntax region  jsModuleGroup        contained matchgroup=jsModuleBraces        start=/{/ end=/}/   contains=jsModuleKeyword,jsModuleComma,jsModuleAs,jsComment,jsFlowTypeKeyword skipwhite skipempty nextgroup=jsFrom fold
    4              0.000032 syntax region  jsSpreadExpression   contained matchgroup=jsSpreadOperator      start=/\.\.\./ end=/[,}\]]\@=/ contains=@jsExpression
    4              0.000025 syntax region  jsRestExpression     contained matchgroup=jsRestOperator        start=/\.\.\./ end=/[,)]\@=/
    4              0.000038 syntax region  jsTernaryIf                    matchgroup=jsTernaryIfOperator   start=/?:\@!/  end=/\%(:\|}\@=\)/  contains=@jsExpression extend skipwhite skipempty nextgroup=@jsExpression
                            " These must occur here or they will be override by jsTernaryIf
    4              0.000017 syntax match   jsOperator           /?\.\ze\_D/
    4              0.000016 syntax match   jsOperator           /??/ skipwhite skipempty nextgroup=@jsExpression
                            
    4              0.000046 syntax match   jsGenerator            contained /\*/ skipwhite skipempty nextgroup=jsFuncName,jsFuncArgs,jsFlowFunctionGroup
    4              0.000031 syntax match   jsFuncName             contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowFunctionGroup
    4              0.000032 syntax region  jsFuncArgExpression    contained matchgroup=jsFuncArgOperator start=/=/ end=/[,)]\@=/ contains=@jsExpression extend
    4              0.000012 syntax match   jsFuncArgCommas        contained ','
    4              0.000029 syntax keyword jsArguments            contained arguments
    4              0.000023 syntax keyword jsForAwait             contained await skipwhite skipempty nextgroup=jsParenRepeat
                            
                            " Matches a single keyword argument with no parens
    4              0.000034 syntax match   jsArrowFuncArgs  /\<\K\k*\ze\s*=>/ skipwhite contains=jsFuncArgs skipwhite skipempty nextgroup=jsArrowFunction extend
                            " Matches a series of arguments surrounded in parens
    4              0.000034 syntax match   jsArrowFuncArgs  /([^()]*)\ze\s*=>/ contains=jsFuncArgs skipempty skipwhite nextgroup=jsArrowFunction extend
                            
    4              0.000089 exe 'syntax match jsFunction /\<function\>/      skipwhite skipempty nextgroup=jsGenerator,jsFuncName,jsFuncArgs,jsFlowFunctionGroup skipwhite '.(exists('g:javascript_conceal_function') ? 'conceal cchar='.g:javascript_conceal_function : '')
    4              0.000051 exe 'syntax match jsArrowFunction /=>/           skipwhite skipempty nextgroup=jsFuncBlock,jsCommentFunction '.(exists('g:javascript_conceal_arrow_function') ? 'conceal cchar='.g:javascript_conceal_arrow_function : '')
    4              0.000043 exe 'syntax match jsArrowFunction /()\ze\s*=>/   skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_noarg_arrow_function') ? 'conceal cchar='.g:javascript_conceal_noarg_arrow_function : '')
    4              0.000041 exe 'syntax match jsArrowFunction /_\ze\s*=>/    skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_underscore_arrow_function') ? 'conceal cchar='.g:javascript_conceal_underscore_arrow_function : '')
                            
                            " Classes
    4              0.000025 syntax keyword jsClassKeyword           contained class
    4              0.000026 syntax keyword jsExtendsKeyword         contained extends skipwhite skipempty nextgroup=@jsExpression
    4              0.000017 syntax match   jsClassNoise             contained /\./
    4              0.000039 syntax match   jsClassFuncName          contained /\<\K\k*\ze\s*[(<]/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowClassFunctionGroup
    4              0.000052 syntax match   jsClassMethodType        contained /\<\%([gs]et\|static\)\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsAsyncKeyword,jsClassFuncName,jsClassProperty
    4              0.000098 syntax region  jsClassDefinition                  start=/\<class\>/ end=/\(\<extends\>\s\+\)\@<!{\@=/ contains=jsClassKeyword,jsExtendsKeyword,jsClassNoise,@jsExpression,jsFlowClassGroup skipwhite skipempty nextgroup=jsCommentClass,jsClassBlock,jsFlowClassGroup
    4              0.000038 syntax match   jsClassProperty          contained /\<\K\k*\ze\s*[=;]/ skipwhite skipempty nextgroup=jsClassValue,jsFlowClassDef
    4              0.000022 syntax region  jsClassValue             contained start=/=/ end=/\_[;}]\@=/ contains=@jsExpression
    4              0.000045 syntax region  jsClassPropertyComputed  contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsFuncArgs,jsClassValue extend
    4              0.000052 syntax region  jsClassStringKey         contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs
                            
                            " Destructuring
    4              0.000012 syntax match   jsDestructuringPropertyValue     contained /\k\+/
    4              0.000025 syntax match   jsDestructuringProperty          contained /\k\+\ze\s*=/ skipwhite skipempty nextgroup=jsDestructuringValue
    4              0.000024 syntax match   jsDestructuringAssignment        contained /\k\+\ze\s*:/ skipwhite skipempty nextgroup=jsDestructuringValueAssignment
    4              0.000022 syntax region  jsDestructuringValue             contained start=/=/ end=/[,}\]]\@=/ contains=@jsExpression extend
    4              0.000068 syntax region  jsDestructuringValueAssignment   contained start=/:/ end=/[,}=]\@=/ contains=jsDestructuringPropertyValue,jsDestructuringBlock,jsNoise,jsDestructuringNoise skipwhite skipempty nextgroup=jsDestructuringValue extend
    4              0.000014 syntax match   jsDestructuringNoise             contained /[,[\]]/
    4              0.000051 syntax region  jsDestructuringPropertyComputed  contained matchgroup=jsDestructuringBraces start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsDestructuringValue,jsDestructuringValueAssignment,jsDestructuringNoise extend fold
                            
                            " Comments
    4              0.000062 syntax keyword jsCommentTodo    contained TODO FIXME XXX TBD NOTE
    4              0.000032 syntax region  jsComment        start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
    4              0.000029 syntax region  jsComment        start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell fold extend keepend
    4              0.000024 syntax region  jsEnvComment     start=/\%^#!/ end=/$/ display
                            
                            " Specialized Comments - These are special comment regexes that are used in
                            " odd places that maintain the proper nextgroup functionality. It sucks we
                            " can't make jsComment a skippable type of group for nextgroup
    4              0.000052 syntax region  jsCommentFunction    contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn extend keepend
    4              0.000045 syntax region  jsCommentFunction    contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn fold extend keepend
    4              0.000041 syntax region  jsCommentClass       contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup extend keepend
    4              0.000042 syntax region  jsCommentClass       contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup fold extend keepend
    4              0.000038 syntax region  jsCommentIfElse      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock extend keepend
    4              0.000038 syntax region  jsCommentIfElse      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock fold extend keepend
    4              0.000035 syntax region  jsCommentRepeat      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock extend keepend
    4              0.000036 syntax region  jsCommentRepeat      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock fold extend keepend
                            
                            " Decorators
    4              0.000026 syntax match   jsDecorator                    /^\s*@/ nextgroup=jsDecoratorFunction
    4              0.000026 syntax match   jsDecoratorFunction  contained /\h[a-zA-Z0-9_.]*/ nextgroup=jsParenDecorator
                            
    4              0.000011 if exists("javascript_plugin_jsdoc")
                              runtime extras/jsdoc.vim
                              " NGDoc requires JSDoc
                              if exists("javascript_plugin_ngdoc")
                                runtime extras/ngdoc.vim
                              endif
    4              0.000002 endif
                            
    4              0.000008 if exists("javascript_plugin_flow")
                              runtime extras/flow.vim
    4              0.000002 endif
                            
    4              0.000406 syntax cluster jsExpression  contains=jsBracket,jsParen,jsObject,jsTernaryIf,jsTaggedTemplate,jsTemplateString,jsString,jsRegexpString,jsNumber,jsFloat,jsOperator,jsOperatorKeyword,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsArrowFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsFuncCall,jsUndefined,jsNan,jsPrototype,jsBuiltins,jsNoise,jsClassDefinition,jsArrowFunction,jsArrowFuncArgs,jsParensError,jsComment,jsArguments,jsThis,jsSuper,jsDo,jsForAwait,jsAsyncKeyword,jsStatement,jsDot
    4              0.000085 syntax cluster jsAll         contains=@jsExpression,jsStorageClass,jsConditional,jsRepeat,jsReturn,jsException,jsTry,jsNoise,jsBlockLabel
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    4              0.000008 if version >= 508 || !exists("did_javascript_syn_inits")
    4              0.000004   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
    4              0.000003   else
    4              0.000027     command -nargs=+ HiLink hi def link <args>
    4              0.000002   endif
    4              0.000035   HiLink jsComment              Comment
    4              0.000023   HiLink jsEnvComment           PreProc
    4              0.000016   HiLink jsParensIfElse         jsParens
    4              0.000015   HiLink jsParensRepeat         jsParens
    4              0.000015   HiLink jsParensSwitch         jsParens
    4              0.000015   HiLink jsParensCatch          jsParens
    4              0.000020   HiLink jsCommentTodo          Todo
    4              0.000025   HiLink jsString               String
    4              0.000024   HiLink jsObjectKeyString      String
    4              0.000024   HiLink jsTemplateString       String
    4              0.000023   HiLink jsObjectStringKey      String
    4              0.000023   HiLink jsClassStringKey       String
    4              0.000022   HiLink jsTaggedTemplate       StorageClass
    4              0.000024   HiLink jsTernaryIfOperator    Operator
    4              0.000024   HiLink jsRegexpString         String
    4              0.000024   HiLink jsRegexpBoundary       SpecialChar
    4              0.000023   HiLink jsRegexpQuantifier     SpecialChar
    4              0.000023   HiLink jsRegexpOr             Conditional
    4              0.000024   HiLink jsRegexpMod            SpecialChar
    4              0.000024   HiLink jsRegexpBackRef        SpecialChar
    4              0.000017   HiLink jsRegexpGroup          jsRegexpString
    4              0.000022   HiLink jsRegexpCharClass      Character
    4              0.000023   HiLink jsCharacter            Character
    4              0.000023   HiLink jsPrototype            Special
    4              0.000021   HiLink jsConditional          Conditional
    4              0.000024   HiLink jsBranch               Conditional
    4              0.000021   HiLink jsLabel                Label
    4              0.000021   HiLink jsReturn               Statement
    4              0.000021   HiLink jsRepeat               Repeat
    4              0.000021   HiLink jsDo                   Repeat
    4              0.000021   HiLink jsStatement            Statement
    4              0.000020   HiLink jsException            Exception
    4              0.000021   HiLink jsTry                  Exception
    4              0.000020   HiLink jsFinally              Exception
    4              0.000020   HiLink jsCatch                Exception
    4              0.000022   HiLink jsAsyncKeyword         Keyword
    4              0.000022   HiLink jsForAwait             Keyword
    4              0.000024   HiLink jsArrowFunction        Type
    4              0.000032   HiLink jsFunction             Type
    4              0.000014   HiLink jsGenerator            jsFunction
    4              0.000015   HiLink jsArrowFuncArgs        jsFuncArgs
    4              0.000021   HiLink jsFuncName             Function
    4              0.000022   HiLink jsFuncCall             Function
    4              0.000014   HiLink jsClassFuncName        jsFuncName
    4              0.000021   HiLink jsObjectFuncName       Function
    4              0.000020   HiLink jsArguments            Special
    4              0.000025   HiLink jsError                Error
    4              0.000024   HiLink jsParensError          Error
    4              0.000018   HiLink jsOperatorKeyword      jsOperator
    4              0.000025   HiLink jsOperator             Operator
    4              0.000027   HiLink jsOf                   Operator
    4              0.000022   HiLink jsStorageClass         StorageClass
    4              0.000020   HiLink jsClassKeyword         Keyword
    4              0.000020   HiLink jsExtendsKeyword       Keyword
    4              0.000022   HiLink jsThis                 Special
    4              0.000022   HiLink jsSuper                Constant
    4              0.000023   HiLink jsNan                  Number
    4              0.000024   HiLink jsNull                 Type
    4              0.000023   HiLink jsUndefined            Type
    4              0.000024   HiLink jsNumber               Number
    4              0.000022   HiLink jsFloat                Float
    4              0.000022   HiLink jsBooleanTrue          Boolean
    4              0.000022   HiLink jsBooleanFalse         Boolean
    4              0.000017   HiLink jsObjectColon          jsNoise
    4              0.000019   HiLink jsNoise                Noise
    4              0.000015   HiLink jsDot                  Noise
    4              0.000014   HiLink jsBrackets             Noise
    4              0.000014   HiLink jsParens               Noise
    4              0.000013   HiLink jsBraces               Noise
    4              0.000013   HiLink jsFuncBraces           Noise
    4              0.000013   HiLink jsFuncParens           Noise
    4              0.000013   HiLink jsClassBraces          Noise
    4              0.000013   HiLink jsClassNoise           Noise
    4              0.000014   HiLink jsIfElseBraces         Noise
    4              0.000013   HiLink jsTryCatchBraces       Noise
    4              0.000013   HiLink jsModuleBraces         Noise
    4              0.000013   HiLink jsObjectBraces         Noise
    4              0.000014   HiLink jsObjectSeparator      Noise
    4              0.000013   HiLink jsFinallyBraces        Noise
    4              0.000013   HiLink jsRepeatBraces         Noise
    4              0.000022   HiLink jsSwitchBraces         Noise
    4              0.000023   HiLink jsSpecial              Special
    4              0.000015   HiLink jsTemplateBraces       Noise
    4              0.000021   HiLink jsGlobalObjects        Constant
    4              0.000021   HiLink jsGlobalNodeObjects    Constant
    4              0.000021   HiLink jsExceptions           Constant
    4              0.000021   HiLink jsBuiltins             Constant
    4              0.000021   HiLink jsImport               Include
    4              0.000021   HiLink jsExport               Include
    4              0.000022   HiLink jsExportDefault        StorageClass
    4              0.000018   HiLink jsExportDefaultGroup   jsExportDefault
    4              0.000021   HiLink jsModuleAs             Include
    4              0.000017   HiLink jsModuleComma          jsNoise
    4              0.000015   HiLink jsModuleAsterisk       Noise
    4              0.000021   HiLink jsFrom                 Include
    4              0.000021   HiLink jsDecorator            Special
    4              0.000021   HiLink jsDecoratorFunction    Function
    4              0.000015   HiLink jsParensDecorator      jsParens
    4              0.000016   HiLink jsFuncArgOperator      jsFuncArgs
    4              0.000017   HiLink jsClassProperty        jsObjectKey
    4              0.000017   HiLink jsObjectShorthandProp  jsObjectKey
    4              0.000022   HiLink jsSpreadOperator       Operator
    4              0.000023   HiLink jsRestOperator         Operator
    4              0.000016   HiLink jsRestExpression       jsFuncArgs
    4              0.000014   HiLink jsSwitchColon          Noise
    4              0.000023   HiLink jsClassMethodType      Type
    4              0.000024   HiLink jsObjectMethodType     Type
    4              0.000014   HiLink jsClassDefinition      jsFuncName
    4              0.000024   HiLink jsBlockLabel           Identifier
    4              0.000017   HiLink jsBlockLabelKey        jsBlockLabel
                            
    4              0.000013   HiLink jsDestructuringBraces     Noise
    4              0.000015   HiLink jsDestructuringProperty   jsFuncArgs
    4              0.000015   HiLink jsDestructuringAssignment jsObjectKey
    4              0.000014   HiLink jsDestructuringNoise      Noise
                            
    4              0.000014   HiLink jsCommentFunction      jsComment
    4              0.000014   HiLink jsCommentClass         jsComment
    4              0.000015   HiLink jsCommentIfElse        jsComment
    4              0.000014   HiLink jsCommentRepeat        jsComment
                            
    4              0.000021   HiLink jsDomErrNo             Constant
    4              0.000021   HiLink jsDomNodeConsts        Constant
    4              0.000024   HiLink jsDomElemAttrs         Label
    4              0.000024   HiLink jsDomElemFuncs         PreProc
                            
    4              0.000021   HiLink jsHtmlEvents           Special
    4              0.000024   HiLink jsHtmlElemAttrs        Label
    4              0.000024   HiLink jsHtmlElemFuncs        PreProc
                            
    4              0.000024   HiLink jsCssStyles            Label
                            
    4              0.000008   delcommand HiLink
    4              0.000002 endif
                            
                            " Define the htmlJavaScript for HTML syntax html.vim
    4              0.000034 syntax cluster  htmlJavaScript       contains=@jsAll,jsImport,jsExport
    4              0.000009 syntax cluster  javaScriptExpression contains=@jsAll
                            
                            " Vim's default html.vim highlights all javascript as 'Special'
    4              0.000014 hi! def link javaScript              NONE
                            
    4              0.000009 let b:current_syntax = "javascript"
    4              0.000008 if main_syntax == 'javascript'
    4              0.000009   unlet main_syntax
    4              0.000006 endif

SCRIPT  /usr/share/nvim/runtime/syntax/javascript.vim
Sourced 4 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2018 Jul 28
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    4              0.000010 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
    4              0.000008   if exists("b:current_syntax")
    4              0.000004     finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            
                            syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
                            syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
                            syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
                            syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
                            syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            syn match   javaScriptSpecialCharacter "'\\.'"
                            syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
                            syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
                            syn keyword javaScriptConditional	if else switch
                            syn keyword javaScriptRepeat		while for do in
                            syn keyword javaScriptBranch		break continue
                            syn keyword javaScriptOperator		new delete instanceof typeof
                            syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
                            syn keyword javaScriptStatement		return with
                            syn keyword javaScriptBoolean		true false
                            syn keyword javaScriptNull		null undefined
                            syn keyword javaScriptIdentifier	arguments this var let
                            syn keyword javaScriptLabel		case default
                            syn keyword javaScriptException		try catch finally throw
                            syn keyword javaScriptMessage		alert confirm prompt status
                            syn keyword javaScriptGlobal		self window top parent
                            syn keyword javaScriptMember		document event location 
                            syn keyword javaScriptDeprecated	escape unescape
                            syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
                            syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
                            if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
                                syn keyword javaScriptFunction	function
                                syn match	javaScriptBraces	   "[{}\[\]]"
                                syn match	javaScriptParens	   "[()]"
                            endif
                            
                            syn sync fromstart
                            syn sync maxlines=100
                            
                            if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            hi def link javaScriptComment		Comment
                            hi def link javaScriptLineComment		Comment
                            hi def link javaScriptCommentTodo		Todo
                            hi def link javaScriptSpecial		Special
                            hi def link javaScriptStringS		String
                            hi def link javaScriptStringD		String
                            hi def link javaScriptStringT		String
                            hi def link javaScriptCharacter		Character
                            hi def link javaScriptSpecialCharacter	javaScriptSpecial
                            hi def link javaScriptNumber		javaScriptValue
                            hi def link javaScriptConditional		Conditional
                            hi def link javaScriptRepeat		Repeat
                            hi def link javaScriptBranch		Conditional
                            hi def link javaScriptOperator		Operator
                            hi def link javaScriptType			Type
                            hi def link javaScriptStatement		Statement
                            hi def link javaScriptFunction		Function
                            hi def link javaScriptBraces		Function
                            hi def link javaScriptError		Error
                            hi def link javaScrParenError		javaScriptError
                            hi def link javaScriptNull			Keyword
                            hi def link javaScriptBoolean		Boolean
                            hi def link javaScriptRegexpString		String
                            
                            hi def link javaScriptIdentifier		Identifier
                            hi def link javaScriptLabel		Label
                            hi def link javaScriptException		Exception
                            hi def link javaScriptMessage		Keyword
                            hi def link javaScriptGlobal		Keyword
                            hi def link javaScriptMember		Keyword
                            hi def link javaScriptDeprecated		Exception 
                            hi def link javaScriptReserved		Keyword
                            hi def link javaScriptDebug		Debug
                            hi def link javaScriptConstant		Label
                            hi def link javaScriptEmbed		Special
                            
                            
                            
                            let b:current_syntax = "javascript"
                            if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /home/max/.local/share/nvim/plugged/vim-styled-components/after/syntax/javascript.vim
Sourced 4 times
Total time:   0.066442
 Self time:   0.034630

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:   styled-components (js/ts)
                            " Maintainer: Karl Fleischmann <fleischmann.karl@gmail.com>
                            " URL:        https://github.com/styled-components/vim-styled-components
                            
    4              0.000009 if exists("b:current_syntax")
    4              0.000008   let s:current_syntax=b:current_syntax
    4              0.000005   unlet b:current_syntax
    4              0.000002 endif
                            
                            
                            " fix for "-" before cssPositioningProp
                            "   - needs to be above CSS include to not match cssVendor definitions
    4              0.000050 syn region cssCustomPositioningPrefix contained
                                  \ start='-' end='\%(\s\{-}:\)\@='
                                  \ contains=cssPositioningProp
                            
                            " introduce CSS cluster from built-in (or single third party syntax file)
    4   0.032485   0.000672 syn include @CSS syntax/css.vim
                            
                            " try to include CSS3 definitions from multiple files
                            " this is only possible on vim version above 7
    4              0.000007 if v:version >= 700
    4              0.000003   try
    4              0.002924     syn include @CSS3 syntax/css/*.vim
    4              0.000041   catch
    4              0.000005   endtry
    4              0.000002 endif
                            
                            " TODO: include react-native keywords
                            
                            " define custom cssAttrRegion
                            "   - add ",", "`" and "{" to the end characters
                            "   - add "cssPseudoClassId" to it's containing elements
                            "     this will incorrectly highlight pseudo elements incorrectly used as
                            "     attributes but correctly highlight actual attributes
    4              0.005792 syn region cssCustomAttrRegion contained
                                  \ start=":" end="\ze\%(;\|)\|{\|}\|`\)"
                                  \ contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,
                                  \          cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,
                                  \          cssError,cssAttrComma,cssNoise,cssPseudoClassId,
                                  \          jsTemplateExpression,
                                  \          typescriptInterpolation,typescriptTemplateSubstitution
    4              0.008293 syn region cssCustomAttrRegion contained
                                  \ start="transition\s*:" end="\ze\%(;\|)\|{\|}\|`\)"
                                  \ contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,
                                  \          cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,
                                  \          cssVendor,cssError,cssAttrComma,cssNoise,cssPseudoClassId,
                                  \          jsTemplateExpression,
                                  \          typescriptInterpolation,typescriptTemplateSubstitution
                            
                            " define custom css elements to not utilize cssDefinition
    4              0.006490 syn region cssCustomMediaBlock contained fold transparent matchgroup=cssBraces
                                  \ start="{" end="}"
                                  \ contains=css.*Attr,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,
                                  \          cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,
                                  \          cssUnicodeEscape,cssVendor,cssTagName,cssClassName,
                                  \          cssIdentifier,cssPseudoClass,cssSelectorOp,cssSelectorOp2,
                                  \          cssAttributeSelector
    4              0.003951 syn region cssCustomPageWrap contained transparent matchgroup=cssBraces
                                  \ start="{" end="}"
                                  \ contains=cssPageMargin,cssPageProp,cssCustomAttrRegion,css.*Prop,
                                  \          cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,
                                  \          cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,
                                  \          cssHacks
    4              0.000038 syn match cssCustomPageMargin contained skipwhite skipnl
                                  \ "@\%(\%(top\|left\|right\|bottom\)-\%(left\|center\|right\|middle\|bottom\)\)\%(-corner\)\="
    4              0.000022 syn match cssCustomKeyFrameSelector "\%(\d*%\|\<from\>\|\<to\>\)" contained
                                  \ skipwhite skipnl
                            
                            " define css include customly to overwrite nextgroup
    4              0.000098 syn region cssInclude start="@media\>" end="\ze{" skipwhite skipnl
                                  \ contains=cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,
                                  \          cssMediaMediaAttr,cssVencor,cssMediaType,cssIncludeKeyword,
                                  \          cssMediaComma,cssComment
                                  \ nextgroup=cssCustomMediaBlock
                            
                            " define all non-contained css definitions
    4              0.000094 syn cluster CSSTop
                                  \ contains=cssTagName,cssSelectorOp,cssAttributeSelector,cssClassName,
                                  \          cssBraces,cssIdentifier,cssIncludeKeyword,cssPage,cssKeyFrame,
                                  \          cssFontDescriptor,cssAttrComma,cssPseudoClass,cssUnicodeEscape
                            
                            " custom highlights for styled components
                            "   - "&" inside top level
                            "   - cssTagName inside of jsStrings inside of styledPrefix regions
                            "     TODO: override highlighting of cssTagName with more subtle one
    4              0.000014 syn match  styledAmpersand contained "&"
    4              0.000053 syn region styledTagNameString matchgroup=jsString contained
                                  \ start=+'+ end=+'+ skip=+\\\%(\'\|$\)+
                                  \ contains=cssTagName
    4              0.000036 syn region styledTagNameString matchgroup=jsString contained
                                  \ start=+"+ end=+"+ skip=+\\\%(\"\|$\)+
                                  \ contains=cssTagName
    4              0.000032 syn region styledTagNameString matchgroup=jsString contained
                                  \ start=+`+ end=+`+ skip=+\\\%(\`\|$\)+
                                  \ contains=cssTagName
                            
                            " define custom API sections that trigger the styledDefinition highlighting
    4              0.000088 syn match styledPrefix "\<styled\>\.\k\+"
                                  \ transparent fold
                                  \ nextgroup=styledDefinition
                                  \ contains=cssTagName,javascriptTagRef
                                  \ containedin=jsFuncBlock,jsParen,jsObject,jsObjectValue
    4              0.000079 syn match styledPrefix "\.\<attrs\>\s*(\%(\n\|\s\|.\)\{-})"
                                  \ transparent fold extend
                                  \ nextgroup=styledDefinition
                                  \ contains=jsObject,jsParen
                                  \ containedin=jsFuncBlock,jsParen,jsObject,jsObjectValue
    4              0.000053 syn match styledPrefix "\.\<extend\>"
                                  \ transparent fold
                                  \ nextgroup=styledDefinition
                                  \ containedin=jsFuncBlock,jsParen,jsObject,jsObjectValue
                            
                            " define emotion css prop
                            " to bypass problems from top-level defined xml/js definitions, this
                            " plugin re-defines keywords/noise for highlighting inside of the custom
                            " xmlAttrib definition
    4              0.000016 syn keyword styledXmlRegionKeyword css contained
    4              0.000016 syn match   styledXmlRegionNoise "\%(=\|{\|}\)" contained
                            " only include styledDefinitions inside of xmlAttribs, that are wrapped
                            " in `css={}` regions, `keepend` is necessary to correctly break on the
                            " higher-level xmlAttrib region end
    4              0.000045 syn region styledXmlRegion
                                  \ start="\<css\>={" end="}"
                                  \ keepend fold
                                  \ containedin=xmlAttrib
                                  \ contains=styledXmlRegionKeyword,styledXmlRegionNoise,styledDefinition
                            
                            " define nested region for indenting
    4              0.000023 syn region styledNestedRegion contained transparent
                                  \ matchgroup=cssBraces
                                  \ start="{" end="}"
                            
                            " re-define cssError to be highlighted correctly in styledNestedRegion
    4              0.000012 syn match cssError contained "{@<>"
                            
                            " extend javascript matches to trigger styledDefinition highlighting
    4              0.000041 syn match jsTaggedTemplate extend
                                  \ "\<css\>\|\.\<resolve\>\|\.\<global\>\|\<keyframes\>\|\<injectGlobal\>\|\<fontFace\>\|\<createGlobalStyle\>"
                                  \ nextgroup=styledDefinition
    4              0.000023 syn match jsFuncCall "\<styled\>\s*(.\+)" transparent
                                  \ nextgroup=styledDefinition
    4              0.000031 syn match jsFuncCall "\<styled\>\s*(\%('\k\+'\|\"\k\+\"\|`\k\+`\))"
                                  \ contains=styledTagNameString
                                  \ nextgroup=styledDefinition
    4              0.000026 syn match jsFuncCall "\.\<withComponent\>\s*(\%('\k\+'\|\"\k\+\"\|`\k\+`\))"
                                  \ contains=styledTagNameString
    4              0.000035 syn match jsFuncCall "\<dc\>\s*(\%('\k\+'\|\"\k\+\"\|`\k\+`\))\%((\)\@="
                                  \ contains=styledTagNameString
                                  \ nextgroup=styledDefinitionArgument
                            
                            " inject css highlighting into custom jsTemplateString region
                            "   - use `extend` to not end all nested jsTemplateExpression on the first
                            "     closing one
    4              0.005176 syn region styledDefinition contained transparent fold extend
                                  \ start="`" end="`" skip="\\\%(`\|$\)"
                                  \ contains=@CSSTop,
                                  \          css.*Prop,cssValue.*,cssColor,cssUrl,cssImportant,cssError,
                                  \          cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,
                                  \          cssHacks,
                                  \          cssCustom.*,
                                  \          jsComment,jsTemplateExpression,
                                  \          typescriptInterpolation,typescriptTemplateSubstitution,
                                  \          styledAmpersand,styledNestedRegion
    4              0.000019 syn region styledDefinitionArgument contained transparent start=+(+ end=+)+
                                  \ contains=styledDefinition
                            
                            """ yajs specific extensions
                            " define template tag keywords, that trigger styledDefinitions again to be
                            " contained in and also do contain the `javascriptTagRef` region
    4              0.000042 syn match javascriptTagRefStyledPrefix transparent fold
                                  \ "\<css\>\|\<keyframes\>\|\<injectGlobal\>\|\<fontFace\>\|\<createGlobalStyle\>"
                                  \ containedin=javascriptTagRef
                                  \ contains=javascriptTagRef
                                  \ nextgroup=styledDefinition
                            " extend the yajs clusters to include the previously and extraneously defined
                            " styled-related matches
    4              0.000032 syn cluster javascriptExpression
                                  \ add=styledPrefix,jsFuncCall,javascriptTagRefStyledPrefix
    4              0.000019 syn cluster javascriptAfterIdentifier add=styledPrefix,jsFuncCall
                            
                            " color the custom highlight elements
    4              0.000022 hi def link cssCustomKeyFrameSelector  Constant
    4              0.000017 hi def link cssCustomPositioningPrefix StorageClass
    4              0.000014 hi def link styledAmpersand            Special
                            
    4              0.000016 hi def link styledXmlRegionKeyword Type
    4              0.000008 hi def link styledXmlRegionNoise   Noise
    4              0.000015 hi def link styledXmlRegion        String
                            
                            
    4              0.000013 if exists("s:current_syntax")
    4              0.000008   let b:current_syntax=s:current_syntax
    4              0.000004 endif

SCRIPT  /usr/share/nvim/runtime/syntax/css.vim
Sourced 4 times
Total time:   0.031800
 Self time:   0.031800

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/JulesWang/css.vim
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " Last Change:  2019 Jul. 29
                            
                            " quit when a syntax file was already loaded
    4              0.000010 if !exists("main_syntax")
    4              0.000008   if exists("b:current_syntax")
                                finish
    4              0.000002   endif
    4              0.000010   let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    4              0.000002 endif
                            
    4              0.000017 let s:cpo_save = &cpo
    4              0.000025 set cpo&vim
                            
    4              0.000004 syn case ignore
                            
                            " HTML4 tags
    4              0.000023 syn keyword cssTagName abbr address area a b base
    4              0.000014 syn keyword cssTagName bdo blockquote body br button
    4              0.000018 syn keyword cssTagName caption cite code col colgroup dd del
    4              0.000015 syn keyword cssTagName dfn div dl dt em fieldset form
    4              0.000015 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    4              0.000022 syn keyword cssTagName iframe input ins isindex kbd label legend li
    4              0.000034 syn keyword cssTagName link map menu meta noscript ol optgroup
    4              0.000016 syn keyword cssTagName option p param pre q s samp script small
    4              0.000012 syn keyword cssTagName span strong sub sup tbody td
    4              0.000015 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    4              0.000009 syn keyword cssTagName object svg
    4              0.000021 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    4              0.000014 syn keyword cssTagName article aside audio bdi canvas command data
    4              0.000015 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    4              0.000014 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    4              0.000012 syn keyword cssTagName output progress rt rp ruby section
    4              0.000012 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    4              0.000011 syn match cssTagName "\*"
                            
                            " selectors
    4              0.000018 syn match cssSelectorOp "[,>+~]"
    4              0.000019 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    4              0.000077 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    4              0.000039 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    4              0.000011 syn match cssClassNameDot contained '\.'
                            
    4              0.000003 try
    4              0.000024 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    4              0.000004 endtry
                            
                            " digits
    4              0.000031 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    4              0.000027 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    4              0.000046 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\)\>" contains=cssUnitDecorators
    4              0.000021 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    4              0.000029 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    4              0.000026 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    4              0.000025 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    4              0.000030 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    4              0.000012 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    4              0.000013 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    4              0.000019 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    4              0.000025 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    4              0.000029 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    4              0.000017 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    4              0.000018 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    4              0.000016 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    4              0.000021 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    4              0.000013 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    4              0.000014 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    4              0.000027 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    4              0.000023 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    4              0.000022 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    4              0.000017 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    4              0.000020 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    4              0.000023 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    4              0.000064 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    4              0.000052 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    4              0.000020 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    4              0.000059 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    4              0.000051 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    4              0.000061 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    4              0.000060 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    4              0.000013 syn keyword cssColor contained thistle tomato turquoise violet wheat
    4              0.000009 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    4              0.000005 syn case match
    4              0.000071 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    4              0.000003 syn case ignore
                            
    4              0.000021 syn match cssImportant contained "!\s*important\>"
    4              0.000019 syn match cssCustomProp contained "--[a-zA-Z0-9-_]*"
                            
    4              0.000012 syn match cssColor contained "\<transparent\>"
    4              0.000013 syn match cssColor contained "\<currentColor\>"
    4              0.000011 syn match cssColor contained "\<white\>"
    4              0.000023 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    4              0.000019 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    4              0.000019 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    4              0.000063 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    4              0.001572 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    4              0.000067 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    4              0.000066 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    4              0.000074 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    4              0.000077 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    4              0.000019 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    4              0.000010 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    4              0.000020 syn keyword cssCommonAttr contained auto none inherit all default normal
    4              0.000015 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    4              0.000041 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    4              0.000013 syn keyword cssAnimationAttr contained alternate reverse
    4              0.000014 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    4              0.000010 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    4              0.000008 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    4              0.000007 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    4              0.000035 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    4              0.000014 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    4              0.000012 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    4              0.000013 syn match cssBackgroundAttr contained "\<no-repeat\>"
    4              0.000036 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    4              0.000010 syn keyword cssBackgroundAttr contained cover contain
                            
    4              0.000028 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    4              0.000021 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    4              0.000022 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    4              0.000013 syn match cssBorderProp contained "\<box-decoration-break\>"
    4              0.000011 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    4              0.000015 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    4              0.000015 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    4              0.000009 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    4              0.000008 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    4              0.000022 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    4              0.000017 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    4              0.000015 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    4              0.000013 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    4              0.000015 syn keyword cssBoxAttr contained visible hidden scroll auto
    4              0.000014 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    4              0.000011 syn keyword cssCascadeProp contained all
    4              0.000013 syn keyword cssCascadeAttr contained initial unset revert
                            
    4              0.000011 syn keyword cssColorProp contained opacity
    4              0.000013 syn match cssColorProp contained "\<color-profile\>"
    4              0.000015 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    4              0.000020 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    4              0.000007 syn keyword cssDimensionProp contained height
    4              0.000007 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    4              0.000027 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    4              0.000019 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    4              0.000008 syn keyword cssFlexibleBoxProp contained order
                            
    4              0.000020 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    4              0.000012 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    4              0.000014 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    4              0.000015 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    4              0.000064 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    4              0.000015 syn keyword cssFontAttr contained icon menu caption
    4              0.000012 syn match cssFontAttr contained "\<message-box\>"
    4              0.000017 syn match cssFontAttr contained "\<status-bar\>"
    4              0.000008 syn keyword cssFontAttr contained larger smaller
    4              0.000016 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    4              0.000015 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    4              0.000014 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    4              0.000044 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    4              0.000011 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    4              0.000008 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    4              0.000020 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    4              0.000008 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    4              0.000008 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    4              0.000008 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    4              0.000012 syn match cssFontProp contained "\<font-smooth\>"
    4              0.000017 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    4              0.000020 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    4              0.000026 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    4              0.000008 syn keyword cssMultiColumnProp contained columns
    4              0.000013 syn keyword cssMultiColumnAttr contained balance medium
    4              0.000011 syn keyword cssMultiColumnAttr contained always left right page column
    4              0.000015 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    4              0.000018 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    4              0.000016 syn match cssInteractProp contained "\<pointer-events\>"
    4              0.000022 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    4              0.000013 syn keyword cssGeneratedContentProp contained quotes crop
    4              0.000015 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    4              0.000011 syn match cssGeneratedContentProp contained "\<move-to\>"
    4              0.000013 syn match cssGeneratedContentProp contained "\<page-policy\>"
    4              0.000023 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    4              0.000014 syn match cssGridProp contained "\<grid\>"
    4              0.000018 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    4              0.000018 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    4              0.000013 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    4              0.000016 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    4              0.000022 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    4              0.000023 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    4              0.000025 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    4              0.000016 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    4              0.000020 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    4              0.000014 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    4              0.000008 syn keyword cssListAttr contained inside outside
                            
    4              0.000014 syn keyword cssPositioningProp contained bottom clear clip display float left
    4              0.000012 syn keyword cssPositioningProp contained position right top visibility
    4              0.000012 syn match cssPositioningProp contained "\<z-index\>"
    4              0.000014 syn keyword cssPositioningAttr contained block compact grid
    4              0.000031 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    4              0.000009 syn keyword cssPositioningAttr contained left right both
    4              0.000012 syn match cssPositioningAttr contained "\<list-item\>"
    4              0.000020 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    4              0.000013 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    4              0.000012 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    4              0.000016 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    4              0.000031 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    4              0.000020 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    4              0.000014 syn keyword cssTextProp contained color direction hyphens
    4              0.000039 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    4              0.000027 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    4              0.000019 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    4              0.000013 syn match cssTextProp contained "\<white-space\>"
    4              0.000013 syn match cssTextProp contained "\<hanging-punctuation\>"
    4              0.000011 syn match cssTextProp contained "\<tab-size\>"
    4              0.000016 syn match cssTextProp contained "\<punctuation-trim\>"
    4              0.000017 syn match cssTextAttr contained "\<line-through\>"
    4              0.000014 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    4              0.000011 syn keyword cssTextAttr contained ltr rtl embed nowrap
    4              0.000013 syn keyword cssTextAttr contained underline overline blink sub super middle
    4              0.000010 syn keyword cssTextAttr contained capitalize uppercase lowercase
    4              0.000010 syn keyword cssTextAttr contained justify baseline sub super
    4              0.000012 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    4              0.000013 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    4              0.000014 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    4              0.000010 syn keyword cssTextAttr contained start end adjacent
    4              0.000018 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    4              0.000011 syn keyword cssTextAttr contained distribute kashida first last
    4              0.000011 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    4              0.000011 syn match cssTextAttr contained "\<break-all\>"
    4              0.000011 syn match cssTextAttr contained "\<break-word\>"
    4              0.000007 syn keyword cssTextAttr contained manual
    4              0.000012 syn match cssTextAttr contained "\<bidi-override\>"
                            
    4              0.000021 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    4              0.000014 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    4              0.000013 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    4              0.000027 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    4              0.000019 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    4              0.000015 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    4              0.000014 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    4              0.000015 syn match cssUIProp contained "\<box-sizing\>"
    4              0.000023 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    4              0.000008 syn keyword cssUIProp contained cursor
    4              0.000022 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    4              0.000013 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    4              0.000012 syn keyword cssUIAttr contained progress wait text cell move
    4              0.000013 syn match cssUIAttr contained "\<context-menu\>"
    4              0.000012 syn match cssUIAttr contained "\<no-drop\>"
    4              0.000011 syn match cssUIAttr contained "\<not-allowed\>"
    4              0.000011 syn match cssUIAttr contained "\<all-scroll\>"
    4              0.000013 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    4              0.000013 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    4              0.000011 syn match cssUIProp contained "\<ime-mode\>"
    4              0.000010 syn keyword cssUIAttr contained active inactive disabled
                            
    4              0.000019 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    4              0.000018 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    4              0.000007 syn keyword cssUIAttr contained invert
                            
    4              0.000007 syn keyword cssUIProp contained icon resize
    4              0.000009 syn keyword cssUIAttr contained both horizontal vertical
                            
    4              0.000011 syn match cssUIProp contained "\<text-overflow\>"
    4              0.000008 syn keyword cssUIAttr contained clip ellipsis
                            
    4              0.000012 syn match cssUIProp contained "\<image-rendering\>"
    4              0.000007 syn keyword cssUIAttr contained pixellated
    4              0.000011 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    4              0.000012 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    4              0.000015 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    4              0.000022 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    4              0.000022 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    4              0.000008 syn keyword cssUIProp contained appearance
    4              0.000013 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    4              0.000022 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    4              0.000036 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    4              0.000014 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    4              0.000019 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    4              0.000007 syn keyword cssAuralAttr contained silent
    4              0.000012 syn match cssAuralAttr contained "\<spell-out\>"
    4              0.000008 syn keyword cssAuralAttr contained non mix
    4              0.000013 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    4              0.000017 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    4              0.000010 syn keyword cssAuralAttr contained leftwards rightwards behind
    4              0.000010 syn keyword cssAuralAttr contained below level above lower higher
    4              0.000017 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    4              0.000009 syn keyword cssAuralAttr contained faster slower
    4              0.000014 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    4              0.000017 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    4              0.000057 syn keyword cssMediaProp contained width height orientation scan
    4              0.000020 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    4              0.000016 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    4              0.000017 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    4              0.000024 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    4              0.000017 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    4              0.000035 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    4              0.000038 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    4              0.000013 syn keyword cssPageProp contained content size
    4              0.000008 syn keyword cssPageProp contained orphans widows
    4              0.000011 syn keyword cssFontDescriptorProp contained src
    4              0.000043 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    4              0.000021 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    4              0.000012 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    4              0.000014 syn match cssBraces contained "[{}]"
    4              0.000016 syn match cssError contained "{@<>"
    4              0.004197 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    4              0.000017 syn match cssBraceError "}"
    4              0.000015 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    4              0.000058 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    4              0.000016 syn keyword cssPseudoClassId contained link visited active hover before after left right
    4              0.000015 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    4              0.000020 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    4              0.000019 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    4              0.000050 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ
                            " ------------------------------------
                            " Vendor specific properties
    4              0.000011 syn match cssPseudoClassId contained  "\<selection\>"
    4              0.000013 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    4              0.000014 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    4              0.000038 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    4              0.000012 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    4              0.000025 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    4              0.000017 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    4              0.000015 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    4              0.000014 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    4              0.000040 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    4              0.000037 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    4              0.000015 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    4              0.000011 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    4              0.005695 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    4              0.008175 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    4              0.000034 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    4              0.000016 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    4              0.000098 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    4              0.000021 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    4              0.000044 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    4              0.000016 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    4              0.000044 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    4              0.000090 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    4              0.000050 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    4              0.000049 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    4              0.004126 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    4              0.000011 if main_syntax == "css"
    4              0.000006   syn sync minlines=10
    4              0.000003 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    4              0.000028 hi def link cssComment Comment
    4              0.000020 hi def link cssVendor Comment
    4              0.000018 hi def link cssHacks Comment
    4              0.000018 hi def link cssTagName Statement
    4              0.000022 hi def link cssDeprecated Error
    4              0.000018 hi def link cssSelectorOp Special
    4              0.000017 hi def link cssSelectorOp2 Special
    4              0.000016 hi def link cssAttrComma Special
                            
    4              0.000013 hi def link cssAnimationProp cssProp
    4              0.000008 hi def link cssBackgroundProp cssProp
    4              0.000014 hi def link cssBorderProp cssProp
    4              0.000008 hi def link cssBoxProp cssProp
    4              0.000008 hi def link cssCascadeProp cssProp
    4              0.000008 hi def link cssColorProp cssProp
    4              0.000011 hi def link cssContentForPagedMediaProp cssProp
    4              0.000008 hi def link cssDimensionProp cssProp
    4              0.000007 hi def link cssFlexibleBoxProp cssProp
    4              0.000007 hi def link cssFontProp cssProp
    4              0.000008 hi def link cssGeneratedContentProp cssProp
    4              0.000007 hi def link cssGridProp cssProp
    4              0.000007 hi def link cssHyerlinkProp cssProp
    4              0.000007 hi def link cssInteractProp cssProp
    4              0.000011 hi def link cssLineboxProp cssProp
    4              0.000007 hi def link cssListProp cssProp
    4              0.000010 hi def link cssMarqueeProp cssProp
    4              0.000008 hi def link cssMultiColumnProp cssProp
    4              0.000010 hi def link cssPagedMediaProp cssProp
    4              0.000009 hi def link cssPositioningProp cssProp
    4              0.000010 hi def link cssPrintProp cssProp
    4              0.000010 hi def link cssRubyProp cssProp
    4              0.000010 hi def link cssSpeechProp cssProp
    4              0.000007 hi def link cssTableProp cssProp
    4              0.000007 hi def link cssTextProp cssProp
    4              0.000007 hi def link cssTransformProp cssProp
    4              0.000007 hi def link cssTransitionProp cssProp
    4              0.000007 hi def link cssUIProp cssProp
    4              0.000007 hi def link cssIEUIProp cssProp
    4              0.000007 hi def link cssAuralProp cssProp
    4              0.000010 hi def link cssRenderProp cssProp
    4              0.000007 hi def link cssMobileTextProp cssProp
                            
    4              0.000012 hi def link cssAnimationAttr cssAttr
    4              0.000008 hi def link cssBackgroundAttr cssAttr
    4              0.000008 hi def link cssBorderAttr cssAttr
    4              0.000007 hi def link cssBoxAttr cssAttr
    4              0.000011 hi def link cssContentForPagedMediaAttr cssAttr
    4              0.000010 hi def link cssDimensionAttr cssAttr
    4              0.000008 hi def link cssFlexibleBoxAttr cssAttr
    4              0.000007 hi def link cssFontAttr cssAttr
    4              0.000008 hi def link cssGeneratedContentAttr cssAttr
    4              0.000010 hi def link cssGridAttr cssAttr
    4              0.000010 hi def link cssHyerlinkAttr cssAttr
    4              0.000007 hi def link cssInteractAttr cssAttr
    4              0.000010 hi def link cssLineboxAttr cssAttr
    4              0.000007 hi def link cssListAttr cssAttr
    4              0.000010 hi def link cssMarginAttr cssAttr
    4              0.000010 hi def link cssMarqueeAttr cssAttr
    4              0.000007 hi def link cssMultiColumnAttr cssAttr
    4              0.000010 hi def link cssPaddingAttr cssAttr
    4              0.000010 hi def link cssPagedMediaAttr cssAttr
    4              0.000007 hi def link cssPositioningAttr cssAttr
    4              0.000008 hi def link cssGradientAttr cssAttr
    4              0.000007 hi def link cssPrintAttr cssAttr
    4              0.000010 hi def link cssRubyAttr cssAttr
    4              0.000010 hi def link cssSpeechAttr cssAttr
    4              0.000007 hi def link cssTableAttr cssAttr
    4              0.000007 hi def link cssTextAttr cssAttr
    4              0.000010 hi def link cssTransformAttr cssAttr
    4              0.000007 hi def link cssTransitionAttr cssAttr
    4              0.000007 hi def link cssUIAttr cssAttr
    4              0.000007 hi def link cssIEUIAttr cssAttr
    4              0.000007 hi def link cssAuralAttr cssAttr
    4              0.000010 hi def link cssRenderAttr cssAttr
    4              0.000008 hi def link cssCascadeAttr cssAttr
    4              0.000008 hi def link cssCommonAttr cssAttr
                            
    4              0.000017 hi def link cssPseudoClassId PreProc
    4              0.000021 hi def link cssPseudoClassLang Constant
    4              0.000019 hi def link cssValueLength Number
    4              0.000019 hi def link cssValueInteger Number
    4              0.000018 hi def link cssValueNumber Number
    4              0.000019 hi def link cssValueAngle Number
    4              0.000018 hi def link cssValueTime Number
    4              0.000018 hi def link cssValueFrequency Number
    4              0.000017 hi def link cssFunction Constant
    4              0.000018 hi def link cssURL String
    4              0.000017 hi def link cssFunctionName Function
    4              0.000017 hi def link cssFunctionComma Function
    4              0.000016 hi def link cssColor Constant
    4              0.000017 hi def link cssIdentifier Function
    4              0.000016 hi def link cssAtRule Include
    4              0.000016 hi def link cssAtKeyword PreProc
    4              0.000016 hi def link cssImportant Special
    4              0.000017 hi def link cssCustomProp Special
    4              0.000015 hi def link cssBraces Function
    4              0.000017 hi def link cssBraceError Error
    4              0.000017 hi def link cssError Error
    4              0.000017 hi def link cssUnicodeEscape Special
    4              0.000018 hi def link cssStringQQ String
    4              0.000018 hi def link cssStringQ String
    4              0.000018 hi def link cssAttributeSelector String
    4              0.000015 hi def link cssMediaType Special
    4              0.000022 hi def link cssMediaComma Normal
    4              0.000016 hi def link cssAtRuleLogical Statement
    4              0.000007 hi def link cssMediaProp cssProp
    4              0.000008 hi def link cssMediaAttr cssAttr
    4              0.000015 hi def link cssPagePseudo PreProc
    4              0.000008 hi def link cssPageMarginProp cssAtKeyword
    4              0.000007 hi def link cssPageProp cssProp
    4              0.000016 hi def link cssKeyFrameProp Constant
    4              0.000019 hi def link cssFontDescriptor Special
    4              0.000008 hi def link cssFontDescriptorProp cssProp
    4              0.000007 hi def link cssFontDescriptorAttr cssAttr
    4              0.000019 hi def link cssUnicodeRange Constant
    4              0.000017 hi def link cssClassName Function
    4              0.000016 hi def link cssClassNameDot Function
    4              0.000015 hi def link cssProp StorageClass
    4              0.000016 hi def link cssAttr Constant
    4              0.000018 hi def link cssUnitDecorators Number
    4              0.000009 hi def link cssNoise Noise
                            
    4              0.000010 let b:current_syntax = "css"
                            
    4              0.000007 if main_syntax == 'css'
    4              0.000009   unlet main_syntax
    4              0.000002 endif
                            
    4              0.000024 let &cpo = s:cpo_save
    4              0.000005 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /home/max/.local/share/nvim/plugged/rainbow/autoload/rainbow_main.vim
Sourced 1 time
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                            " Copyright 2013 LuoChen (luochen1990@gmail.com). Licensed under the Apache License 2.0.
                            
    1              0.000086 let s:rainbow_conf = {
                            \	'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
                            \	'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
                            \	'guis': [''],
                            \	'cterms': [''],
                            \	'operators': '_,_',
                            \	'contains_prefix': 'TOP',
                            \	'parentheses_options': '',
                            \	'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
                            \	'separately': {
                            \		'*': {},
                            \		'markdown': {
                            \			'parentheses_options': 'containedin=markdownCode contained',
                            \		},
                            \		'lisp': {
                            \			'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
                            \		},
                            \		'haskell': {
                            \			'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/\v\{\ze[^-]/ end=/}/ fold'],
                            \		},
                            \		'ocaml': {
                            \			'parentheses': ['start=/(\ze[^*]/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/\[|/ end=/|\]/ fold', 'start=/{/ end=/}/ fold'],
                            \		},
                            \		'tex': {
                            \			'parentheses_options': 'containedin=texDocZone',
                            \			'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
                            \		},
                            \		'vim': {
                            \			'parentheses_options': 'containedin=vimFuncBody,vimExecute',
                            \			'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/', 'start=/{/ end=/}/ fold'],
                            \		},
                            \		'xml': {
                            \			'syn_name_prefix': 'xmlRainbow',
                            \			'parentheses': ['start=/\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>/ end=#</\z1># fold'],
                            \		},
                            \		'xhtml': {
                            \			'parentheses': ['start=/\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>/ end=#</\z1># fold'],
                            \		},
                            \		'html': {
                            \			'parentheses': ['start=/\v\<((script|style|area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
                            \		},
                            \		'perl': {
                            \			'syn_name_prefix': 'perlBlockFoldRainbow',
                            \		},
                            \		'php': {
                            \			'syn_name_prefix': 'phpBlockRainbow',
                            \			'contains_prefix': '',
                            \			'parentheses': ['start=/(/ end=/)/ containedin=@htmlPreproc contains=@phpClTop', 'start=/\[/ end=/\]/ containedin=@htmlPreproc contains=@phpClTop', 'start=/{/ end=/}/ containedin=@htmlPreproc contains=@phpClTop', 'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold contains_prefix=TOP'],
                            \		},
                            \		'stylus': {
                            \			'parentheses': ['start=/{/ end=/}/ fold contains=@colorableGroup'],
                            \		},
                            \		'css': 0,
                            \		'sh': 0,
                            \	}
                            \}
                            
    1              0.000003 fun s:eq(x, y)
                            	return type(a:x) == type(a:y) && a:x == a:y
                            endfun
                            
    1              0.000002 fun s:gcd(a, b)
                            	let [a, b, t] = [a:a, a:b, 0]
                            	while b != 0
                            		let t = b
                            		let b = a % b
                            		let a = t
                            	endwhile
                            	return a
                            endfun
                            
    1              0.000002 fun s:lcm(a, b)
                            	return (a:a / s:gcd(a:a, a:b)) * a:b
                            endfun
                            
    1              0.000002 fun rainbow_main#gen_config(ft)
                            	let g = exists('g:rainbow_conf')? g:rainbow_conf : {}
                            	"echom 'g:rainbow_conf:' string(g)
                            	let s = get(g, 'separately', {})
                            	"echom 'g:rainbow_conf.separately:' string(s)
                            	let dft_conf = extend(copy(s:rainbow_conf), g) | unlet dft_conf.separately
                            	"echom 'default config options:' string(dft_conf)
                            	let dx_conf = s:rainbow_conf.separately['*']
                            	"echom 'default star config:' string(dx_conf)
                            	let ds_conf = get(s:rainbow_conf.separately, a:ft, dx_conf)
                            	"echom 'default separately config:' string(ds_conf)
                            	let ux_conf = get(s, '*', ds_conf)
                            	"echom 'user star config:' string(ux_conf)
                            	let us_conf = get(s, a:ft, ux_conf)
                            	"echom 'user separately config:' string(us_conf)
                            	let af_conf = (s:eq(us_conf, 'default') ? ds_conf : us_conf)
                            	"echom 'almost finally config:' string(af_conf)
                            	if s:eq(af_conf, 0)
                            		return 0
                            	else
                            		let conf = extend(extend({'syn_name_prefix': substitute(a:ft, '\v\A+(\a)', '\u\1', 'g').'Rainbow'}, dft_conf), af_conf)
                            		let conf.cycle = (has('gui_running') || (has('termguicolors') && &termguicolors)) ? s:lcm(len(conf.guifgs), len(conf.guis)) : s:lcm(len(conf.ctermfgs), len(conf.cterms))
                            		return conf
                            	endif
                            endfun
                            
    1              0.000002 fun rainbow_main#gen_configs(ft)
                            	return filter(map(split(a:ft, '\v\.'), 'rainbow_main#gen_config(v:val)'), 'type(v:val) == type({})')
                            endfun
                            
    1              0.000001 fun rainbow_main#load()
                            	let b:rainbow_confs = rainbow_main#gen_configs(&filetype)
                            	for conf in b:rainbow_confs
                            		call rainbow#syn(conf)
                            		call rainbow#hi(conf)
                            	endfor
                            endfun
                            
    1              0.000001 fun rainbow_main#clear()
                            	if !exists('b:rainbow_confs') | return | endif
                            	for conf in b:rainbow_confs
                            		call rainbow#hi_clear(conf)
                            		call rainbow#syn_clear(conf)
                            	endfor
                            	unlet b:rainbow_confs
                            endfun
                            
    1              0.000001 fun rainbow_main#toggle()
                            	if exists('b:rainbow_confs')
                            		call rainbow_main#clear()
                            	else
                            		call rainbow_main#load()
                            	endif
                            endfun
                            

SCRIPT  /home/max/.local/share/nvim/plugged/rainbow/autoload/rainbow.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " Copyright 2013 LuoChen (luochen1990@gmail.com). Licensed under the Apache License 2.0.
                            
    1              0.000006 if exists('s:loaded') | finish | endif | let s:loaded = 1
                            
    1              0.000002 fun s:trim(s)
                            	return substitute(a:s, '\v^\s*(.{-})\s*$', '\1', '')
                            endfun
                            
    1              0.000002 fun s:concat(strs)
                            	return join(filter(a:strs, "v:val !~ '^[ ]*$'"), ',')
                            endfun
                            
    1              0.000002 fun s:resolve_parenthesis_with(init_state, p)
                            	let [paren, contained, containedin, contains_prefix, contains, op] = a:init_state
                            	let p = (type(a:p) == type([])) ? ((len(a:p) == 3) ? printf('start=#%s# step=%s end=#%s#', a:p[0], op, a:p[-1]) : printf('start=#%s# end=#%s#', a:p[0], a:p[-1])) : a:p "NOTE: preprocess the old style parentheses config
                            
                            	let ls = split(p, '\v%(%(start|step|end)\=(.)%(\1@!.)*\1[^ ]*|\w+%(\=[^ ]*)?) ?\zs', 0)
                            	for s in ls
                            		let [k, v] = [matchstr(s, '^[^=]\+\ze\(=\|$\)'), matchstr(s, '^[^=]\+=\zs.*')]
                            		if k == 'step'
                            			let op = s:trim(v)
                            		elseif k == 'contains_prefix'
                            			let contains_prefix = s:trim(v)
                            		elseif k == 'contains'
                            			let contains = s:concat([contains, s:trim(v)])
                            		elseif k == 'containedin'
                            			let containedin = s:concat([containedin, s:trim(v)])
                            		elseif k == 'contained'
                            			let contained = 1
                            		else
                            			let paren .= s
                            		endif
                            	endfor
                            	let rst = [paren, contained, containedin, contains_prefix, contains, op]
                            	"echom json_encode(rst)
                            	return rst
                            endfun
                            
    1              0.000002 fun s:resolve_parenthesis_from_config(config)
                            	return s:resolve_parenthesis_with(['', 0, '', a:config.contains_prefix, '', a:config.operators], a:config.parentheses_options)
                            endfun
                            
    1              0.000002 fun s:synID(prefix, group, lv, id)
                            	return a:prefix.'_lv'.a:lv.'_'.a:group.a:id
                            endfun
                            
    1              0.000002 fun s:synGroupID(prefix, group, lv)
                            	return a:prefix.a:group.'_lv'.a:lv
                            endfun
                            
    1              0.000001 fun rainbow#syn(config)
                            	let conf = a:config
                            	let prefix = conf.syn_name_prefix
                            	let cycle = conf.cycle
                            
                            	let glob_paran_opts = s:resolve_parenthesis_from_config(conf)
                            	let b:rainbow_loaded = cycle
                            	for id in range(len(conf.parentheses))
                            		let [paren, contained, containedin, contains_prefix, contains, op] = s:resolve_parenthesis_with(glob_paran_opts, conf.parentheses[id])
                            		for lv in range(cycle)
                            			let lv2 = ((lv + cycle - 1) % cycle)
                            			let [rid, pid, gid2] = [s:synID(prefix, 'r', lv, id), s:synID(prefix, 'p', lv, id), s:synGroupID(prefix, 'Regions', lv2)]
                            
                            			if len(op) > 2
                            				exe 'syn match '.s:synID(prefix, 'o', lv, id).' '.op.' containedin='.s:synID(prefix, 'r', lv, id).' contained'
                            			endif
                            
                            			let real_contained = (lv == 0)? (contained? 'contained ' : '') : 'contained '
                            			let real_containedin = (lv == 0)? s:concat([containedin, '@'.gid2]) : '@'.gid2
                            			let real_contains = s:concat([contains_prefix, contains])
                            			exe 'syn region '.rid.' matchgroup='.pid.' '.real_contained.'containedin='.real_containedin.' contains='.real_contains.' '.paren
                            		endfor
                            	endfor
                            	for lv in range(cycle)
                            		exe 'syn cluster '.s:synGroupID(prefix, 'Regions', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "r", lv, v:val)'), ',')
                            		exe 'syn cluster '.s:synGroupID(prefix, 'Parentheses', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "p", lv, v:val)'), ',')
                            		exe 'syn cluster '.s:synGroupID(prefix, 'Operators', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "o", lv, v:val)'), ',')
                            	endfor
                            	exe 'syn cluster '.prefix.'Regions contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Regions", v:val)'), ',')
                            	exe 'syn cluster '.prefix.'Parentheses contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Parentheses", v:val)'), ',')
                            	exe 'syn cluster '.prefix.'Operators contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Operators", v:val)'), ',')
                            	if has_key(conf, 'after') | for cmd in conf.after | exe cmd | endfor | endif
                            endfun
                            
    1              0.000002 fun rainbow#syn_clear(config)
                            	let conf = a:config
                            	let prefix = conf.syn_name_prefix
                            
                            	for id in range(len(conf.parentheses))
                            		for lv in range(conf.cycle)
                            			let [rid, oid] = [s:synID(prefix, 'r', lv, id), s:synID(prefix, 'o', lv, id)]
                            			exe 'syn clear '.rid
                            			exe 'syn clear '.oid
                            		endfor
                            	endfor
                            endfun
                            
    1              0.000001 fun rainbow#hi(config)
                            	let conf = a:config
                            	let prefix = conf.syn_name_prefix
                            
                            	for id in range(len(conf.parentheses))
                            		for lv in range(conf.cycle)
                            			let [pid, oid] = [s:synID(prefix, 'p', lv, id), s:synID(prefix, 'o', lv, id)]
                            			let ctermfg = conf.ctermfgs[lv % len(conf.ctermfgs)]
                            			let guifg = conf.guifgs[lv % len(conf.guifgs)]
                            			let cterm = conf.cterms[lv % len(conf.cterms)]
                            			let gui = conf.guis[lv % len(conf.guis)]
                            			let hi_style = 'ctermfg='.ctermfg.' guifg='.guifg.(len(cterm) > 0 ? ' cterm='.cterm : '').(len(gui) > 0 ? ' gui='.gui : '')
                            			exe 'hi '.pid.' '.hi_style
                            			exe 'hi '.oid.' '.hi_style
                            		endfor
                            	endfor
                            endfun
                            
    1              0.000001 fun rainbow#hi_clear(config)
                            	let conf = a:config
                            	let prefix = conf.syn_name_prefix
                            
                            	for id in range(len(conf.parentheses))
                            		for lv in range(conf.cycle)
                            			let [pid, oid] = [s:synID(prefix, 'p', lv, id), s:synID(prefix, 'o', lv, id)]
                            			exe 'hi clear '.pid
                            			exe 'hi clear '.oid
                            		endfor
                            	endfor
                            endfun
                            

SCRIPT  /home/max/.local/share/nvim/plugged/vim-doge/autoload/doge.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000004 let s:save_cpo = &cpoptions
    1              0.000004 set cpoptions&vim
                            
                            ""
                            " @public
                            " Generates documentation based on available patterns in b:doge_patterns.
                            "
                            " arg: Either a count (0 by default) or a string (empty by default).
    1              0.000002 function! doge#generate(arg) abort
                              if doge#buffer#initialized() == v:false
                                return 0
                              endif
                            
                              " Immediately validate if the doc standard is allowed.
                              if index(b:doge_supported_doc_standards, b:doge_doc_standard) < 0
                                echoerr printf(
                                \  '[DoGe] "%s" is not a valid %s doc standard, available doc standard are: %s',
                                \  b:doge_doc_standard,
                                \  &filetype,
                                \  string(b:doge_supported_doc_standards)
                                \)
                              endif
                            
                              " Store old search register.
                              let s:oldsearch = @/
                            
                              " If the command is run with a count or a string as argument, the user is
                              " requesting for a specific doc standard.
                              " If no matching standards are found, or no arg (count or string) is given,
                              " just use whatever is currently set.
                              if exists('b:doge_supported_doc_standards')
                                if type(a:arg) ==# type(0) && a:arg != 0
                                  if a:arg <= len(b:doge_supported_doc_standards)
                                    let b:doge_doc_standard = b:doge_supported_doc_standards[a:arg - 1]
                                  endif
                                elseif type(a:arg) ==# type('') && !empty(a:arg)
                                  if index(b:doge_supported_doc_standards, a:arg) >= 0
                                    let b:doge_doc_standard = a:arg
                                  endif
                                endif
                              endif
                            
                              if exists('b:doge_patterns')
                                for l:pattern in get(b:doge_patterns, b:doge_doc_standard)
                                  if doge#pattern#generate(l:pattern) == v:false
                                    continue
                                  endif
                            
                                  call doge#activate()
                                  return 1
                                endfor
                              endif
                            endfunction
                            
                            ""
                            " @public
                            " Activate doge buffer mappings, if option is set.
    1              0.000002 function! doge#activate() abort
                              " Ensure lazyredraw is enabled.
                              if get(g:, 'doge_lazyredraw', 1) && &lazyredraw == v:false
                                set lazyredraw
                                let s:doge_lazyredraw = 1
                              endif
                            
                              if g:doge_comment_interactive == v:false || g:doge_buffer_mappings == v:false
                                return
                              endif
                            
                              let [l:f, l:b] = [
                                    \ g:doge_mapping_comment_jump_forward,
                                    \ g:doge_mapping_comment_jump_backward,
                                    \ ]
                              for l:mode in g:doge_comment_jump_modes
                                call execute(printf('%smap <nowait> <silent> <buffer> %s <Plug>(doge-comment-jump-forward)', l:mode, l:f), 'silent!')
                                call execute(printf('%smap <nowait> <silent> <buffer> %s <Plug>(doge-comment-jump-backward)', l:mode, l:b), 'silent!')
                              endfor
                            endfunction
                            
                            ""
                            " @public
                            " Deactivate doge mappings and unlet buffer variable.
                            " Can print a message with the reason of deactivation/termination.
    1              0.000002 function! doge#deactivate() abort
                              " Disable lazyredraw if it was previously enabled.
                              if exists('s:doge_lazyredraw')
                                set nolazyredraw
                                unlet s:doge_lazyredraw
                              endif
                              unlet b:doge_interactive
                            
                              " Restore saved search register.
                              let @/ = s:oldsearch
                            
                              if g:doge_comment_interactive == v:false || g:doge_buffer_mappings == v:false
                                return
                              endif
                            
                              let [l:f, l:b] = [
                                    \ g:doge_mapping_comment_jump_forward,
                                    \ g:doge_mapping_comment_jump_backward,
                                    \ ]
                              for l:mode in g:doge_comment_jump_modes
                                call execute(printf('%sunmap <buffer> %s', l:mode, l:f), 'silent!')
                                call execute(printf('%sunmap <buffer> %s', l:mode, l:b), 'silent!')
                              endfor
                            endfunction
                            
                            ""
                            " @public
                            " Return a list of supported doc standards for the current buffer.
    1              0.000002 function! doge#command_complete(...) abort
                              return filter(copy(get(b:, 'doge_supported_doc_standards', [])), "v:val =~ '^'.a:1")
                            endfunction
                            
                            ""
                            " @public
                            " This function will be triggered on the FileType autocmd and will:
                            " - apply aliases
                            " - remove conflicting doc standards from the previous filetype.
    1              0.000002 function! doge#on_filetype_change() abort
                              " Check if the current filetype is an alias, if so, initialize that filetype.
                              if get(g:, 'doge_ignore_on_filetype_change', 0) == v:true
                                return 0
                              else
                                let l:orig_ft = &filetype
                                for [l:ft, l:aliases] in items(get(g:, 'doge_filetype_aliases'))
                                  if index(l:aliases, l:orig_ft) >= 0
                                    let g:doge_ignore_on_filetype_change = 1
                                    execute('setlocal ft=' . l:ft)
                                    execute('setlocal ft=' . l:orig_ft)
                                    let g:doge_ignore_on_filetype_change = 0
                                    break
                                  endif
                                endfor
                              endif
                            
                              " Remove conflicting doc standards from the previous filetype.
                              if !exists('b:doge_prev_supported_doc_standards')
                                \ && exists('b:doge_supported_doc_standards')
                                " Save the current supported doc standards
                                let b:doge_prev_supported_doc_standards = copy(get(b:, 'doge_supported_doc_standards', []))
                                let b:doge_prev_ft = &filetype
                              elseif exists('b:doge_prev_supported_doc_standards')
                                \ && exists('b:doge_supported_doc_standards')
                                \ && get(b:, 'doge_prev_ft', '') != &filetype
                                " Remove all the doc standards from the previous filetype.
                                " If the current filetype is not an alias of the previous filetype then we
                                " will remove the doc standard.
                                for l:doc in get(b:, 'doge_prev_supported_doc_standards', [])
                                  let l:is_alias = 0
                            
                                  if (has_key(g:doge_filetype_aliases, &filetype) && index(get(g:doge_filetype_aliases, &filetype, []), b:doge_prev_ft) >= 0)
                                        \ || (has_key(g:doge_filetype_aliases, b:doge_prev_ft) && index(get(g:doge_filetype_aliases, b:doge_prev_ft, []), &filetype) >= 0)
                                    let l:is_alias = 1
                                  endif
                            
                                  if l:is_alias == v:false
                                    for [l:ft, l:aliases] in items(get(g:, 'doge_filetype_aliases'))
                                      if index(l:aliases, &filetype) >= 0 && index(l:aliases, b:doge_prev_ft) >= 0
                                        let l:is_alias = 1
                                        break
                                      endif
                                    endfor
                                  endif
                            
                                  if l:is_alias == v:false
                                    let l:doc_idx = index(get(b:, 'doge_supported_doc_standards', []), l:doc)
                                    if l:doc_idx >= 0
                                      call remove(b:doge_supported_doc_standards, l:doc_idx)
                                    endif
                            
                                    if has_key(get(b:, 'doge_patterns', {}), l:doc)
                                      unlet b:doge_patterns[l:doc]
                                    endif
                                  endif
                                endfor
                                let b:doge_prev_supported_doc_standards = copy(b:doge_supported_doc_standards)
                                let b:doge_prev_ft = &filetype
                              endif
                            endfunction
                            
    1              0.000004 let &cpoptions = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /home/max/.local/share/nvim/plugged/splitjoin.vim/ftplugin/jsx/splitjoin.vim
Sourced 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000018 let b:splitjoin_split_callbacks = [
                                  \ 'sj#html#SplitTags',
                                  \ 'sj#html#SplitAttributes',
                                  \ 'sj#js#SplitObjectLiteral',
                                  \ 'sj#js#SplitFatArrowFunction',
                                  \ 'sj#js#SplitArray',
                                  \ 'sj#js#SplitFunction',
                                  \ 'sj#js#SplitOneLineIf',
                                  \ 'sj#js#SplitArgs',
                                  \ 'sj#jsx#SplitSelfClosingTag'
                                  \ ]
                            
    2              0.000013 let b:splitjoin_join_callbacks = [
                                  \ 'sj#html#JoinAttributes',
                                  \ 'sj#jsx#JoinHtmlTag',
                                  \ 'sj#js#JoinFatArrowFunction',
                                  \ 'sj#js#JoinArray',
                                  \ 'sj#js#JoinArgs',
                                  \ 'sj#js#JoinFunction',
                                  \ 'sj#js#JoinOneLineIf',
                                  \ 'sj#js#JoinObjectLiteral',
                                  \ ]

SCRIPT  /home/max/.local/share/nvim/plugged/vim-jsx/after/ftplugin/jsx.vim
Sourced 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim ftplugin file
                            "
                            " Language: JSX (JavaScript)
                            " Maintainer: Max Wang <mxawng@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " modified from html.vim
    2              0.000006 if exists("loaded_matchit")
    2              0.000004   let b:match_ignorecase = 0
    2              0.000006   let s:jsx_match_words = '(:),\[:\],{:},<:>,' .
                                    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(/\@<!>\|$\):<\@<=/\1>'
    2              0.000009   let b:match_words = exists('b:match_words')
                                \ ? b:match_words . ',' . s:jsx_match_words
                                \ : s:jsx_match_words
    2              0.000001 endif
                            
    2              0.000007 setlocal suffixesadd+=.jsx

SCRIPT  /home/max/.local/share/nvim/plugged/vim-styled-components/after/indent/jsx.vim
Sourced 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)

SCRIPT  /home/max/.local/share/nvim/plugged/vim-jsx/after/indent/jsx.vim
Sourced 2 times
Total time:   0.000650
 Self time:   0.000448

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim indent file
                            "
                            " Language: JSX (JavaScript)
                            " Maintainer: Max Wang <mxawng@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " Save the current JavaScript indentexpr.
    2              0.000005 let b:jsx_js_indentexpr = &indentexpr
                            
                            " Prologue; load in XML indentation.
    2              0.000004 if exists('b:did_indent')
    2              0.000003   let s:did_indent=b:did_indent
    2              0.000002   unlet b:did_indent
    2              0.000001 endif
    2   0.000524   0.000322 exe 'runtime! indent/xml.vim'
    2              0.000004 if exists('s:did_indent')
    2              0.000003   let b:did_indent=s:did_indent
    2              0.000001 endif
                            
    2              0.000003 setlocal indentexpr=GetJsxIndent()
                            
                            " JS indentkeys
    2              0.000004 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            " XML indentkeys
    2              0.000004 setlocal indentkeys+=*<Return>,<>>,<<>,/
                            
                            " Multiline end tag regex (line beginning with '>' or '/>')
    2              0.000003 let s:endtag = '^\s*\/\?>\s*;\='
                            
                            " Get all syntax types at the beginning of a given line.
    2              0.000002 fu! SynSOL(lnum)
                              return map(synstack(a:lnum, 1), 'synIDattr(v:val, "name")')
                            endfu
                            
                            " Get all syntax types at the end of a given line.
    2              0.000002 fu! SynEOL(lnum)
                              let lnum = prevnonblank(a:lnum)
                              let col = strlen(getline(lnum))
                              return map(synstack(lnum, col), 'synIDattr(v:val, "name")')
                            endfu
                            
                            " Check if a syntax attribute is XMLish.
    2              0.000002 fu! SynAttrXMLish(synattr)
                              return a:synattr =~ "^xml" || a:synattr =~ "^jsx"
                            endfu
                            
                            " Check if a synstack is XMLish (i.e., has an XMLish last attribute).
    2              0.000002 fu! SynXMLish(syns)
                              return SynAttrXMLish(get(a:syns, -1))
                            endfu
                            
                            " Check if a synstack denotes the end of a JSX block.
    2              0.000002 fu! SynJSXBlockEnd(syns)
                              return get(a:syns, -1) =~ '\%(js\|javascript\)Braces' &&
                                   \ SynAttrXMLish(get(a:syns, -2))
                            endfu
                            
                            " Determine how many jsxRegions deep a synstack is.
    2              0.000002 fu! SynJSXDepth(syns)
                              return len(filter(copy(a:syns), 'v:val ==# "jsxRegion"'))
                            endfu
                            
                            " Check whether `cursyn' continues the same jsxRegion as `prevsyn'.
    2              0.000002 fu! SynJSXContinues(cursyn, prevsyn)
                              let curdepth = SynJSXDepth(a:cursyn)
                              let prevdepth = SynJSXDepth(a:prevsyn)
                            
                              " In most places, we expect the nesting depths to be the same between any
                              " two consecutive positions within a jsxRegion (e.g., between a parent and
                              " child node, between two JSX attributes, etc.).  The exception is between
                              " sibling nodes, where after a completed element (with depth N), we return
                              " to the parent's nesting (depth N - 1).  This case is easily detected,
                              " since it is the only time when the top syntax element in the synstack is
                              " jsxRegion---specifically, the jsxRegion corresponding to the parent.
                              return prevdepth == curdepth ||
                                  \ (prevdepth == curdepth + 1 && get(a:cursyn, -1) ==# 'jsxRegion')
                            endfu
                            
                            " Cleverly mix JS and XML indentation.
    2              0.000002 fu! GetJsxIndent()
                              let cursyn  = SynSOL(v:lnum)
                              let prevsyn = SynEOL(v:lnum - 1)
                            
                              " Use XML indenting iff:
                              "   - the syntax at the end of the previous line was either JSX or was the
                              "     closing brace of a jsBlock whose parent syntax was JSX; and
                              "   - the current line continues the same jsxRegion as the previous line.
                              if (SynXMLish(prevsyn) || SynJSXBlockEnd(prevsyn)) &&
                                    \ SynJSXContinues(cursyn, prevsyn)
                                let ind = XmlIndentGet(v:lnum, 0)
                            
                                " Align '/>' and '>' with '<' for multiline tags.
                                if getline(v:lnum) =~? s:endtag
                                  let ind = ind - &sw
                                endif
                            
                                " Then correct the indentation of any JSX following '/>' or '>'.
                                if getline(v:lnum - 1) =~? s:endtag
                                  let ind = ind + &sw
                                endif
                              else
                                if len(b:jsx_js_indentexpr)
                                  " Invoke the base JS package's custom indenter.  (For vim-javascript,
                                  " e.g., this will be GetJavascriptIndent().)
                                  let ind = eval(b:jsx_js_indentexpr)
                                else
                                  let ind = cindent(v:lnum)
                                endif
                              endif
                            
                              return ind
                            endfu

SCRIPT  /usr/share/nvim/runtime/indent/xml.vim
Sourced 2 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
                            "     Language: xml
                            "   Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Last Changed: July 27, 2019
                            "   Maintainer: Christian Brabandt <cb@256bit.org>
                            " Previous Maintainer:  Johannes Zellner <johannes@zellner.org>
                            " Last Change:
                            " 20190726 - Correctly handle non-tagged data
                            " 20190204 - correctly handle wrap tags
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/5
                            " 20190128 - Make sure to find previous tag
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/4
                            " 20181116 - Fix indentation when tags start with a colon or an underscore
                            "            https://github.com/vim/vim/pull/926
                            " 20181022 - Do not overwrite indentkeys setting
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/1
                            " 20180724 - Correctly indent xml comments https://github.com/vim/vim/issues/3200
                            "
                            " Notes:
                            "   1) does not indent pure non-xml code (e.g. embedded scripts)
                            "       2) will be confused by unbalanced tags in comments
                            "       or CDATA sections.
                            "       2009-05-26 patch by Nikolai Weibull
                            " TODO:     implement pre-like tags, see xml_indent_open / xml_indent_close
                            
                            " Only load this indent file when no other was loaded.
    2              0.000004 if exists("b:did_indent")
                                finish
    2              0.000001 endif
    2              0.000003 let b:did_indent = 1
    2              0.000008 let s:keepcpo= &cpo
    2              0.000011 set cpo&vim
                            
                            " [-- local settings (must come before aborting the script) --]
                            " Attention: Parameter use_syntax_check is used by the docbk.vim indent script
    2              0.000004 setlocal indentexpr=XmlIndentGet(v:lnum,1)
    2              0.000005 setlocal indentkeys=o,O,*<Return>,<>>,<<>,/,{,},!^F
                            " autoindent: used when the indentexpr returns -1
    2              0.000005 setlocal autoindent
                            
    2              0.000004 if !exists('b:xml_indent_open')
    1              0.000002     let b:xml_indent_open = '.\{-}<[:A-Z_a-z]'
                                " pre tag, e.g. <address>
                                " let b:xml_indent_open = '.\{-}<[/]\@!\(address\)\@!'
    2              0.000001 endif
                            
    2              0.000004 if !exists('b:xml_indent_close')
    1              0.000002     let b:xml_indent_close = '.\{-}</'
                                " end pre tag, e.g. </address>
                                " let b:xml_indent_close = '.\{-}</\(address\)\@!'
    2              0.000001 endif
                            
    2              0.000009 let &cpo = s:keepcpo
    2              0.000002 unlet s:keepcpo
                            
                            " [-- finish, if the function already exists --]
    2              0.000004 if exists('*XmlIndentGet')
    1              0.000001     finish
    1              0.000001 endif
                            
    1              0.000004 let s:keepcpo= &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000003 fun! <SID>XmlIndentWithPattern(line, pat)
                                let s = substitute('x'.a:line, a:pat, "\1", 'g')
                                return strlen(substitute(s, "[^\1].*$", '', ''))
                            endfun
                            
                            " [-- check if it's xml --]
    1              0.000002 fun! <SID>XmlIndentSynCheck(lnum)
                                if &syntax != ''
                                    let syn1 = synIDattr(synID(a:lnum, 1, 1), 'name')
                                    let syn2 = synIDattr(synID(a:lnum, strlen(getline(a:lnum)) - 1, 1), 'name')
                                    if syn1 != '' && syn1 !~ 'xml' && syn2 != '' && syn2 !~ 'xml'
                                        " don't indent pure non-xml code
                                        return 0
                                    endif
                                endif
                                return 1
                            endfun
                            
                            " [-- return the sum of indents of a:lnum --]
    1              0.000002 fun! <SID>XmlIndentSum(line, style, add)
                                if <SID>IsXMLContinuation(a:line) && a:style == 0
                                    " no complete tag, add one additional indent level
                                    " but only for the current line
                                    return a:add + shiftwidth()
                                elseif <SID>HasNoTagEnd(a:line)
                                    " no complete tag, return initial indent
                                    return a:add
                                endif
                                if a:style == match(a:line, '^\s*</')
                                    return (shiftwidth() *
                                    \  (<SID>XmlIndentWithPattern(a:line, b:xml_indent_open)
                                    \ - <SID>XmlIndentWithPattern(a:line, b:xml_indent_close)
                                    \ - <SID>XmlIndentWithPattern(a:line, '.\{-}/>'))) + a:add
                                else
                                    return a:add
                                endif
                            endfun
                            
                            " Main indent function
    1              0.000002 fun! XmlIndentGet(lnum, use_syntax_check)
                                " Find a non-empty line above the current line.
                                if prevnonblank(a:lnum - 1) == 0
                                    " Hit the start of the file, use zero indent.
                                    return 0
                                endif
                                " Find previous line with a tag (regardless whether open or closed,
                                " but always restrict the match to a line before the current one
                                " Note: xml declaration: <?xml version="1.0"?>
                                "       won't be found, as it is not a legal tag name
                                let ptag_pattern = '\%(.\{-}<[/:A-Z_a-z]\)'. '\%(\&\%<'. a:lnum .'l\)'
                                let ptag = search(ptag_pattern, 'bnW')
                                " no previous tag
                                if ptag == 0
                                    return 0
                                endif
                            
                                let pline = getline(ptag)
                                let pind  = indent(ptag)
                            
                                let syn_name_start = '' " Syntax element at start of line (excluding whitespace)
                                let syn_name_end = ''   " Syntax element at end of line
                                let curline = getline(a:lnum)
                                if a:use_syntax_check
                                    let check_lnum = <SID>XmlIndentSynCheck(ptag)
                                    let check_alnum = <SID>XmlIndentSynCheck(a:lnum)
                                    if check_lnum == 0 || check_alnum == 0
                                        return indent(a:lnum)
                                    endif
                                    let syn_name_end   = synIDattr(synID(a:lnum, strlen(curline) - 1, 1), 'name')
                                    let syn_name_start = synIDattr(synID(a:lnum, match(curline, '\S') + 1, 1), 'name')
                                endif
                            
                                if syn_name_end =~ 'Comment' && syn_name_start =~ 'Comment'
                                    return <SID>XmlIndentComment(a:lnum)
                                elseif empty(syn_name_start) && empty(syn_name_end)
                                    " non-xml tag content: use indent from 'autoindent'
                                    return pind + shiftwidth()
                                endif
                            
                                " Get indent from previous tag line
                                let ind = <SID>XmlIndentSum(pline, -1, pind)
                                " Determine indent from current line
                                let ind = <SID>XmlIndentSum(curline, 0, ind)
                                return ind
                            endfun
                            
    1              0.000002 func! <SID>IsXMLContinuation(line)
                                " Checks, whether or not the line matches a start-of-tag
                                return a:line !~ '^\s*<'
                            endfunc
                            
    1              0.000002 func! <SID>HasNoTagEnd(line)
                                " Checks whether or not the line matches '>' (so finishes a tag)
                                return a:line !~ '>\s*$'
                            endfunc
                            
                            " return indent for a commented line,
                            " the middle part might be indented one additional level
    1              0.000002 func! <SID>XmlIndentComment(lnum)
                                let ptagopen = search(b:xml_indent_open, 'bnW')
                                let ptagclose = search(b:xml_indent_close, 'bnW')
                                if getline(a:lnum) =~ '<!--'
                                    " if previous tag was a closing tag, do not add
                                    " one additional level of indent
                                    if ptagclose > ptagopen && a:lnum > ptagclose
                                        return indent(ptagclose)
                                    else
                                        " start of comment, add one indentation level
                                        return indent(ptagopen) + shiftwidth()
                                    endif
                                elseif getline(a:lnum) =~ '-->'
                                    " end of comment, same as start of comment
                                    return indent(search('<!--', 'bnW'))
                                else
                                    " middle part of comment, add one additional level
                                    return indent(search('<!--', 'bnW')) + shiftwidth()
                                endif
                            endfunc
                            
    1              0.000007 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            
                            " vim:ts=4 et sts=-1 sw=0

SCRIPT  /home/max/.local/share/nvim/plugged/vim-jsx/after/syntax/jsx.vim
Sourced 2 times
Total time:   0.001435
 Self time:   0.000368

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: JSX (JavaScript)
                            " Maintainer: Max Wang <mxawng@gmail.com>
                            " Depends: pangloss/vim-javascript
                            "
                            " CREDITS: Inspired by Facebook.
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " Prologue; load in XML syntax.
    2              0.000004 if exists('b:current_syntax')
    2              0.000003   let s:current_syntax=b:current_syntax
    2              0.000002   unlet b:current_syntax
    2              0.000001 endif
    2   0.001288   0.000222 syn include @XMLSyntax syntax/xml.vim
    2              0.000003 if exists('s:current_syntax')
    2              0.000002   let b:current_syntax=s:current_syntax
    2              0.000001 endif
                            
                            " Officially, vim-jsx depends on the pangloss/vim-javascript syntax package
                            " (and is tested against it exclusively).  However, in practice, we make some
                            " effort towards compatibility with other packages.
                            "
                            " These are the plugin-to-syntax-element correspondences:
                            "
                            "   - pangloss/vim-javascript:      jsBlock, jsExpression
                            "   - jelera/vim-javascript-syntax: javascriptBlock
                            "   - othree/yajs.vim:              javascriptNoReserved
                            
                            
                            " JSX attributes should color as JS.  Note the trivial end pattern; we let
                            " jsBlock take care of ending the region.
    2              0.000039 syn region xmlString contained start=+{+ end=++ contains=jsBlock,javascriptBlock
                            
                            " JSX comments inside XML tag should color as comment.  Note the trivial end pattern; we let
                            " jsComment take care of ending the region.
    2              0.000010 syn region xmlString contained start=+//+ end=++ contains=jsComment
                            
                            " JSX child blocks behave just like JSX attributes, except that (a) they are
                            " syntactically distinct, and (b) they need the syn-extend argument, or else
                            " nested XML end-tag patterns may end the outer jsxRegion.
    2              0.000015 syn region jsxChild contained start=+{+ end=++ contains=jsBlock,javascriptBlock
                              \ extend
                            
                            " Highlight JSX regions as XML; recursively match.
                            "
                            " Note that we prohibit JSX tags from having a < or word character immediately
                            " preceding it, to avoid conflicts with, respectively, the left shift operator
                            " and generic Flow type annotations (http://flowtype.org/).
    2              0.000033 syn region jsxRegion
                              \ contains=@Spell,@XMLSyntax,jsxRegion,jsxChild,jsBlock,javascriptBlock
                              \ start=+\%(<\|\w\)\@<!<\z([a-zA-Z_][a-zA-Z0-9:\-.]*\>[:,]\@!\)\([^>]*>(\)\@!+
                              \ skip=+<!--\_.\{-}-->+
                              \ end=+</\z1\_\s\{-}>+
                              \ end=+/>+
                              \ keepend
                              \ extend
                            
                            " Add jsxRegion to the lowest-level JS syntax cluster.
    2              0.000007 syn cluster jsExpression add=jsxRegion
                            
                            " Allow jsxRegion to contain reserved words.
    2              0.000004 syn cluster javascriptNoReserved add=jsxRegion

SCRIPT  /usr/share/nvim/runtime/syntax/xml.vim
Sourced 2 times
Total time:   0.001061
 Self time:   0.000680

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	XML
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            "		Author and previous maintainer:
                            "		Paul Siegmann <pauls@euronet.nl>
                            " Last Change:	2013 Jun 07
                            " Filenames:	*.xml
                            " $Id: xml.vim,v 1.3 2006/04/11 21:32:00 vimboss Exp $
                            
                            " CONFIGURATION:
                            "   syntax folding can be turned on by
                            "
                            "      let g:xml_syntax_folding = 1
                            "
                            "   before the syntax file gets loaded (e.g. in ~/.vimrc).
                            "   This might slow down syntax highlighting significantly,
                            "   especially for large files.
                            "
                            " CREDITS:
                            "   The original version was derived by Paul Siegmann from
                            "   Claudio Fleiner's html.vim.
                            "
                            " REFERENCES:
                            "   [1] http://www.w3.org/TR/2000/REC-xml-20001006
                            "   [2] http://www.w3.org/XML/1998/06/xmlspec-report-19980910.htm
                            "
                            "   as <hirauchi@kiwi.ne.jp> pointed out according to reference [1]
                            "
                            "   2.3 Common Syntactic Constructs
                            "   [4]    NameChar    ::=    Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender
                            "   [5]    Name        ::=    (Letter | '_' | ':') (NameChar)*
                            "
                            " NOTE:
                            "   1) empty tag delimiters "/>" inside attribute values (strings)
                            "      confuse syntax highlighting.
                            "   2) for large files, folding can be pretty slow, especially when
                            "      loading a file the first time and viewoptions contains 'folds'
                            "      so that folds of previous sessions are applied.
                            "      Don't use 'foldmethod=syntax' in this case.
                            
                            
                            " Quit when a syntax file was already loaded
    2              0.000003 if exists("b:current_syntax")
                                finish
    2              0.000001 endif
                            
    2              0.000005 let s:xml_cpo_save = &cpo
    2              0.000008 set cpo&vim
                            
    2              0.000001 syn case match
                            
                            " mark illegal characters
    2              0.000008 syn match xmlError "[<&]"
                            
                            " strings (inside tags) aka VALUES
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "                      ^^^^^^^
    2              0.000017 syn region  xmlString contained start=+"+ end=+"+ contains=xmlEntity,@Spell display
    2              0.000007 syn region  xmlString contained start=+'+ end=+'+ contains=xmlEntity,@Spell display
                            
                            
                            " punctuation (within attributes) e.g. <tag xml:foo.attribute ...>
                            "                                              ^   ^
                            " syn match   xmlAttribPunct +[-:._]+ contained display
    2              0.000006 syn match   xmlAttribPunct +[:.]+ contained display
                            
                            " no highlighting for xmlEqual (xmlEqual has no highlighting group)
    2              0.000006 syn match   xmlEqual +=+ display
                            
                            
                            " attribute, everything before the '='
                            "
                            " PROVIDES: @xmlAttribHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "      ^^^^^^^^^^^^^
                            "
    2              0.000013 syn match   xmlAttrib
                                \ +[-'"<]\@1<!\<[a-zA-Z:_][-.0-9a-zA-Z:_]*\>\%(['">]\@!\|$\)+
                                \ contained
                                \ contains=xmlAttribPunct,@xmlAttribHook
                                \ display
                            
                            
                            " namespace spec
                            "
                            " PROVIDES: @xmlNamespaceHook
                            "
                            " EXAMPLE:
                            "
                            " <xsl:for-each select = "lola">
                            "  ^^^
                            "
    2              0.000003 if exists("g:xml_namespace_transparent")
                            syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ transparent
                                \ display
    2              0.000001 else
    2              0.000010 syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ display
    2              0.000001 endif
                            
                            
                            " tag name
                            "
                            " PROVIDES: @xmlTagHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "  ^^^
                            "
    2              0.000012 syn match   xmlTagName
                                \ +<\@1<=[^ /!?<>"']\++
                                \ contained
                                \ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                                \ display
                            
                            
    2              0.000003 if exists('g:xml_syntax_folding')
                            
                                " start tag
                                " use matchgroup=xmlTag to skip over the leading '<'
                                "
                                " PROVIDES: @xmlStartTagHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                " s^^^^^^^^^^^^^^^e
                                "
                                syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
                            
                                " highlight the end tag
                                "
                                " PROVIDES: @xmlTagHook
                                " (should we provide a separate @xmlEndTagHook ?)
                                "
                                " EXAMPLE:
                                "
                                " </tag>
                                " ^^^^^^
                                "
                                syn match   xmlEndTag
                            	\ +</[^ /!?<>"']\+>+
                            	\ contained
                            	\ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
                            
                                " tag elements with syntax-folding.
                                " NOTE: NO HIGHLIGHTING -- highlighting is done by contained elements
                                "
                                " PROVIDES: @xmlRegionHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                "   <!-- comment -->
                                "   <another.tag></another.tag>
                                "   <empty.tag/>
                                "   some data
                                " </tag>
                                "
                                syn region   xmlRegion
                            	\ start=+<\z([^ /!?<>"']\+\)+
                            	\ skip=+<!--\_.\{-}-->+
                            	\ end=+</\z1\_\s\{-}>+
                            	\ matchgroup=xmlEndTag end=+/>+
                            	\ fold
                            	\ contains=xmlTag,xmlEndTag,xmlCdata,xmlRegion,xmlComment,xmlEntity,xmlProcessing,@xmlRegionHook,@Spell
                            	\ keepend
                            	\ extend
                            
    2              0.000001 else
                            
                                " no syntax folding:
                                " - contained attribute removed
                                " - xmlRegion not defined
                                "
    2              0.000015     syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
    2              0.000008     syn match   xmlEndTag
                            	\ +</[^ /!?<>"']\+>+
                            	\ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
    2              0.000001 endif
                            
                            
                            " &entities; compare with dtd
    2              0.000010 syn match   xmlEntity                 "&[^; \t]*;" contains=xmlEntityPunct
    2              0.000003 syn match   xmlEntityPunct  contained "[&.;]"
                            
    2              0.000003 if exists('g:xml_syntax_folding')
                            
                                " The real comments (this implements the comments as defined by xml,
                                " but not all xml pages actually conform to it. Errors are flagged.
                                syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            	\ fold
                            
    2              0.000001 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    2              0.000008     syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            
    2              0.000001 endif
                            
    2              0.000008 syn match xmlCommentStart   contained "<!" nextgroup=xmlCommentPart
    2              0.000007 syn keyword xmlTodo         contained TODO FIXME XXX
    2              0.000003 syn match   xmlCommentError contained "[^><!]"
    2              0.000010 syn region  xmlCommentPart
                                \ start=+--+
                                \ end=+--+
                                \ contained
                                \ contains=xmlTodo,@xmlCommentHook,@Spell
                            
                            
                            " CData sections
                            "
                            " PROVIDES: @xmlCdataHook
                            "
    2              0.000019 syn region    xmlCdata
                                \ start=+<!\[CDATA\[+
                                \ end=+]]>+
                                \ contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook,@Spell
                                \ keepend
                                \ extend
                            
                            " using the following line instead leads to corrupt folding at CDATA regions
                            " syn match    xmlCdata      +<!\[CDATA\[\_.\{-}]]>+  contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook
    2              0.000008 syn match    xmlCdataStart +<!\[CDATA\[+  contained contains=xmlCdataCdata
    2              0.000002 syn keyword  xmlCdataCdata CDATA          contained
    2              0.000003 syn match    xmlCdataEnd   +]]>+          contained
                            
                            
                            " Processing instructions
                            " This allows "?>" inside strings -- good idea?
    2              0.000016 syn region  xmlProcessing matchgroup=xmlProcessingDelim start="<?" end="?>" contains=xmlAttrib,xmlEqual,xmlString
                            
                            
    2              0.000003 if exists('g:xml_syntax_folding')
                            
                                " DTD -- we use dtd.vim here
                                syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ fold
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
    2              0.000001 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    2              0.000017     syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
                            
    2              0.000001 endif
                            
    2              0.000003 syn keyword xmlDocTypeKeyword contained DOCTYPE PUBLIC SYSTEM
    2              0.000007 syn region  xmlInlineDTD contained matchgroup=xmlDocTypeDecl start="\[" end="]" contains=@xmlDTD
    2   0.000415   0.000034 syn include @xmlDTD <sfile>:p:h/dtd.vim
    2              0.000002 unlet b:current_syntax
                            
                            
                            " synchronizing
                            " TODO !!! to be improved !!!
                            
    2              0.000011 syn sync match xmlSyncDT grouphere  xmlDocType +\_.\(<!DOCTYPE\)\@=+
                            " syn sync match xmlSyncDT groupthere  NONE       +]>+
                            
    2              0.000003 if exists('g:xml_syntax_folding')
                                syn sync match xmlSync grouphere   xmlRegion  +\_.\(<[^ /!?<>"']\+\)\@=+
                                " syn sync match xmlSync grouphere  xmlRegion "<[^ /!?<>"']*>"
                                syn sync match xmlSync groupthere  xmlRegion  +</[^ /!?<>"']\+>+
    2              0.000001 endif
                            
    2              0.000001 syn sync minlines=100
                            
                            
                            " The default highlighting.
    2              0.000009 hi def link xmlTodo		Todo
    2              0.000007 hi def link xmlTag		Function
    2              0.000006 hi def link xmlTagName		Function
    2              0.000007 hi def link xmlEndTag		Identifier
    2              0.000003 if !exists("g:xml_namespace_transparent")
    2              0.000006     hi def link xmlNamespace	Tag
    2              0.000001 endif
    2              0.000006 hi def link xmlEntity		Statement
    2              0.000006 hi def link xmlEntityPunct	Type
                            
    2              0.000006 hi def link xmlAttribPunct	Comment
    2              0.000006 hi def link xmlAttrib		Type
                            
    2              0.000006 hi def link xmlString		String
    2              0.000006 hi def link xmlComment		Comment
    2              0.000002 hi def link xmlCommentStart	xmlComment
    2              0.000005 hi def link xmlCommentPart	Comment
    2              0.000007 hi def link xmlCommentError	Error
    2              0.000006 hi def link xmlError		Error
                            
    2              0.000005 hi def link xmlProcessingDelim	Comment
    2              0.000006 hi def link xmlProcessing	Type
                            
    2              0.000006 hi def link xmlCdata		String
    2              0.000005 hi def link xmlCdataCdata	Statement
    2              0.000006 hi def link xmlCdataStart	Type
    2              0.000006 hi def link xmlCdataEnd		Type
                            
    2              0.000005 hi def link xmlDocTypeDecl	Function
    2              0.000005 hi def link xmlDocTypeKeyword	Statement
    2              0.000005 hi def link xmlInlineDTD	Function
                            
    2              0.000002 let b:current_syntax = "xml"
                            
    2              0.000006 let &cpo = s:xml_cpo_save
    2              0.000002 unlet s:xml_cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/dtd.vim
Sourced 2 times
Total time:   0.000376
 Self time:   0.000376

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	DTD (Document Type Definition for XML)
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            "		Author and previous maintainer:
                            "		Daniel Amyot <damyot@site.uottawa.ca>
                            " Last Change:	Tue, 27 Apr 2004 14:54:59 CEST
                            " Filenames:	*.dtd
                            "
                            " REFERENCES:
                            "   http://www.w3.org/TR/html40/
                            "   http://www.w3.org/TR/NOTE-html-970421
                            "
                            " TODO:
                            "   - improve synchronizing.
                            
    2              0.000003 if exists("b:current_syntax")
                                finish
    2              0.000001 endif
    2              0.000006 let s:dtd_cpo_save = &cpo
    2              0.000005 set cpo&vim
                            
    2              0.000003 if !exists("dtd_ignore_case")
                                " I prefer having the case takes into consideration.
    2              0.000001     syn case match
                            else
                                syn case ignore
    2              0.000001 endif
                            
                            
                            " the following line makes the opening <! and
                            " closing > highlighted using 'dtdFunction'.
                            "
                            " PROVIDES: @dtdTagHook
                            "
    2              0.000050 syn region dtdTag matchgroup=dtdFunction
                                \ start=+<!+ end=+>+ matchgroup=NONE
                                \ contains=dtdTag,dtdTagName,dtdError,dtdComment,dtdString,dtdAttrType,dtdAttrDef,dtdEnum,dtdParamEntityInst,dtdParamEntityDecl,dtdCard,@dtdTagHook
                            
    2              0.000003 if !exists("dtd_no_tag_errors")
                                " mark everything as an error which starts with a <!
                                " and is not overridden later. If this is annoying,
                                " it can be switched off by setting the variable
                                " dtd_no_tag_errors.
    2              0.000005     syn region dtdError contained start=+<!+lc=2 end=+>+
    2              0.000001 endif
                            
                            " if this is a html like comment hightlight also
                            " the opening <! and the closing > as Comment.
    2              0.000011 syn region dtdComment		start=+<![ \t]*--+ end=+-->+ contains=dtdTodo,@Spell
                            
                            
                            " proper DTD comment
    2              0.000007 syn region dtdComment contained start=+--+ end=+--+ contains=dtdTodo,@Spell
                            
                            
                            " Start tags (keywords). This is contained in dtdFunction.
                            " Note that everything not contained here will be marked
                            " as error.
    2              0.000009 syn match dtdTagName contained +<!\(ATTLIST\|DOCTYPE\|ELEMENT\|ENTITY\|NOTATION\|SHORTREF\|USEMAP\|\[\)+lc=2,hs=s+2
                            
                            
                            " wildcards and operators
    2              0.000003 syn match  dtdCard contained "|"
    2              0.000003 syn match  dtdCard contained ","
                            " evenutally overridden by dtdEntity
    2              0.000003 syn match  dtdCard contained "&"
    2              0.000003 syn match  dtdCard contained "?"
    2              0.000002 syn match  dtdCard contained "\*"
    2              0.000003 syn match  dtdCard contained "+"
                            
                            " ...and finally, special cases.
    2              0.000003 syn match  dtdCard      "ANY"
    2              0.000003 syn match  dtdCard      "EMPTY"
                            
    2              0.000003 if !exists("dtd_no_param_entities")
                            
                                " highlight parameter entity declarations
                                " and instances. Note that the closing `;'
                                " is optional.
                            
                                " instances
    2              0.000017     syn region dtdParamEntityInst oneline matchgroup=dtdParamEntityPunct
                            	\ start="%[-_a-zA-Z0-9.]\+"he=s+1,rs=s+1
                            	\ skip=+[-_a-zA-Z0-9.]+
                            	\ end=";\|\>"
                            	\ matchgroup=NONE contains=dtdParamEntityPunct
    2              0.000003     syn match  dtdParamEntityPunct contained "\."
                            
                                " declarations
                                " syn region dtdParamEntityDecl oneline matchgroup=dtdParamEntityDPunct start=+<!ENTITY % +lc=8 skip=+[-_a-zA-Z0-9.]+ matchgroup=NONE end="\>" contains=dtdParamEntityDPunct
    2              0.000009     syn match dtdParamEntityDecl +<!ENTITY % [-_a-zA-Z0-9.]*+lc=8 contains=dtdParamEntityDPunct
    2              0.000003     syn match  dtdParamEntityDPunct contained "%\|\."
                            
    2              0.000001 endif
                            
                            " &entities; compare with xml
    2              0.000011 syn match   dtdEntity		      "&[^; \t]*;" contains=dtdEntityPunct
    2              0.000003 syn match   dtdEntityPunct  contained "[&.;]"
                            
                            " Strings are between quotes
    2              0.000014 syn region dtdString    start=+"+ skip=+\\\\\|\\"+  end=+"+ contains=dtdAttrDef,dtdAttrType,dtdEnum,dtdParamEntityInst,dtdEntity,dtdCard
    2              0.000013 syn region dtdString    start=+'+ skip=+\\\\\|\\'+  end=+'+ contains=dtdAttrDef,dtdAttrType,dtdEnum,dtdParamEntityInst,dtdEntity,dtdCard
                            
                            " Enumeration of elements or data between parenthesis
                            "
                            " PROVIDES: @dtdEnumHook
                            "
    2              0.000013 syn region dtdEnum matchgroup=dtdType start="(" end=")" matchgroup=NONE contains=dtdEnum,dtdParamEntityInst,dtdCard,@dtdEnumHook
                            
                            "Attribute types
    2              0.000004 syn keyword dtdAttrType NMTOKEN  ENTITIES  NMTOKENS  ID  CDATA
    2              0.000003 syn keyword dtdAttrType IDREF  IDREFS
                            " ENTITY has to treated special for not overriding <!ENTITY
    2              0.000004 syn match   dtdAttrType +[^!]\<ENTITY+
                            
                            "Attribute Definitions
    2              0.000004 syn match  dtdAttrDef   "#REQUIRED"
    2              0.000004 syn match  dtdAttrDef   "#IMPLIED"
    2              0.000004 syn match  dtdAttrDef   "#FIXED"
                            
    2              0.000001 syn case match
                            " define some common keywords to mark TODO
                            " and important sections inside comments.
    2              0.000003 syn keyword dtdTodo contained TODO FIXME XXX
                            
    2              0.000002 syn sync lines=250
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            " The default highlighting.
    2              0.000007 hi def link dtdFunction		Function
    2              0.000007 hi def link dtdTag		Normal
    2              0.000006 hi def link dtdType		Type
    2              0.000002 hi def link dtdAttrType		dtdType
    2              0.000002 hi def link dtdAttrDef		dtdType
    2              0.000008 hi def link dtdConstant		Constant
    2              0.000002 hi def link dtdString		dtdConstant
    2              0.000002 hi def link dtdEnum		dtdConstant
    2              0.000002 hi def link dtdCard		dtdFunction
                            
    2              0.000005 hi def link dtdEntity		Statement
    2              0.000002 hi def link dtdEntityPunct	dtdType
    2              0.000002 hi def link dtdParamEntityInst	dtdConstant
    2              0.000002 hi def link dtdParamEntityPunct	dtdType
    2              0.000002 hi def link dtdParamEntityDecl	dtdType
    2              0.000002 hi def link dtdParamEntityDPunct dtdComment
                            
    2              0.000005 hi def link dtdComment		Comment
    2              0.000005 hi def link dtdTagName		Statement
    2              0.000006 hi def link dtdError		Error
    2              0.000005 hi def link dtdTodo		Todo
                            
                            
    2              0.000008 let &cpo = s:dtd_cpo_save
    2              0.000002 unlet s:dtd_cpo_save
                            
    2              0.000002 let b:current_syntax = "dtd"
                            
                            " vim: ts=8

SCRIPT  /home/max/.local/share/nvim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2020 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000001 scriptencoding utf-8
                            
    1              0.000003 let s:untracked_jobs = {}
    1              0.000001 let s:mq_jobs        = {}
    1              0.000001 let s:po_jobs        = {}
    1              0.000001 let s:clean_jobs     = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000002 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000001 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000001 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000001 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000001 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000001 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction
                            
    1              0.000001 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction
                            
    1              0.000001 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction
                            
    1              0.000001 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000003 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if g:airline#init#is_windows || !executable('msgfmt')
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000002 elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000001   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
    1              0.000000 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000001 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000001 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /home/max/.local/share/nvim/plugged/coc.nvim/autoload/coc/task.vim
Sourced 1 time
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
                            " ============================================================================
                            " Description: Manage long running tasks.
                            " Author: Qiming Zhao <chemzqm@gmail.com>
                            " Licence: MIT licence
                            " Version: 0.1
                            " Last Modified:  April 08, 2019
                            " ============================================================================
                            
    1              0.000022 let s:is_vim = !has('nvim')
    1              0.000004 let s:running_task = {}
                            
    1              0.000006 function! coc#task#start(id, opts)
                              if coc#task#running(a:id)
                                call coc#task#stop(a:id)
                              endif
                              let cmd = [a:opts['cmd']] + get(a:opts, 'args', [])
                              let cwd = get(a:opts, 'cwd', getcwd())
                              " cmd args cwd pty
                              if s:is_vim
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'err_mode': 'nl',
                                      \ 'out_mode': 'nl',
                                      \ 'err_cb': {channel, message -> s:on_stderr(a:id, [message])},
                                      \ 'out_cb': {channel, message -> s:on_stdout(a:id, [message])},
                                      \ 'exit_cb': {channel, code -> s:on_exit(a:id, code)},
                                      \}
                                if has("patch-8.1.350")
                                  let options['noblock'] = 1
                                endif
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let job = job_start(cmd, options)
                                let status = job_status(job)
                                if status !=# 'run'
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = job
                              else
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'on_stderr': {channel, msgs -> s:on_stderr(a:id, filter(msgs, 'v:val !=""'))},
                                      \ 'on_stdout': {channel, msgs -> s:on_stdout(a:id, filter(msgs, 'v:val !=""'))},
                                      \ 'on_exit': {channel, code -> s:on_exit(a:id, code)},
                                      \ 'detach': get(a:opts, 'detach', 0),
                                      \}
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let chan_id = jobstart(cmd, options)
                                if chan_id <= 0
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = chan_id
                              endif
                              return v:true
                            endfunction
                            
    1              0.000004 function! coc#task#stop(id)
                              let job = get(s:running_task, a:id, v:null)
                              if !job | return | endif
                              if s:is_vim
                                call job_stop(job, 'term')
                              else
                                call jobstop(job)
                              endif
                              sleep 50m
                              let running = coc#task#running(a:id)
                              if running
                                echohl Error | echom 'job '.a:id. ' stop failed.' | echohl None
                              endif
                            endfunction
                            
    1              0.000006 function! s:on_exit(id, code) abort
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if has_key(s:running_task, a:id)
                                call remove(s:running_task, a:id)
                              endif
                              call coc#rpc#notify('TaskExit', [a:id, a:code])
                            endfunction
                            
    1              0.000004 function! s:on_stderr(id, msgs)
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if len(a:msgs)
                                call coc#rpc#notify('TaskStderr', [a:id, a:msgs])
                              endif
                            endfunction
                            
    1              0.000003 function! s:on_stdout(id, msgs)
                              if len(a:msgs)
                                call coc#rpc#notify('TaskStdout', [a:id, a:msgs])
                              endif
                            endfunction
                            
    1              0.000003 function! coc#task#running(id)
                              if !has_key(s:running_task, a:id) == 1
                                return v:false
                              endif
                              let job = s:running_task[a:id]
                              if s:is_vim
                                let status = job_status(job)
                                return status ==# 'run'
                              endif
                              let [code] = jobwait([job], 10)
                              return code == -1
                            endfunction

